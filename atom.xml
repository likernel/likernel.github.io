<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>likernel</title>
  <icon>https://www.gravatar.com/avatar/d0e54b3b2e11646353dba604f4cd06d9</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://likernel.github.io/"/>
  <updated>2018-02-11T14:46:28.577Z</updated>
  <id>http://likernel.github.io/</id>
  
  <author>
    <name>likernel</name>
    <email>daqingv5@foxmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ubuntu下安装Docker</title>
    <link href="http://likernel.github.io/2018/01/31/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85Docker/"/>
    <id>http://likernel.github.io/2018/01/31/Ubuntu下安装Docker/</id>
    <published>2018-01-31T08:51:27.000Z</published>
    <updated>2018-02-11T14:46:28.577Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍在Ubuntu下Docker的安装。</p><h2 id="Ubuntu下安装Docker"><a href="#Ubuntu下安装Docker" class="headerlink" title="Ubuntu下安装Docker"></a>Ubuntu下安装Docker</h2><h4 id="检查当前内核版本："><a href="#检查当前内核版本：" class="headerlink" title="检查当前内核版本："></a>检查当前内核版本：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ uname -r</span><br><span class="line">4.14.0-041400-generic</span><br></pre></td></tr></table></figure><p>内核版本要求最低为 3.10。</p><h4 id="更新apt源"><a href="#更新apt源" class="headerlink" title="更新apt源"></a>更新apt源</h4><p>Docker默认APT仓库中的版本较低，因此要设置APT使用Docker的官方源：<br>1.更新包信息，确保APT能使用https的方式，并安装CA证书：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install apt-transport-https ca-certificates</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>2.添加GPG密钥：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D</span><br></pre></td></tr></table></figure></p><p>3.在文件 /etc/apt/sources.list.d/docker.list中添加相应的源。对于16.04版本的系统：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;deb https://apt.dockerproject.org/repo ubuntu-xenial main&quot; | sudo tee /etc/apt/sources.list.d/docker.list</span><br></pre></td></tr></table></figure></p><p>4.更新APT包索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></p><p>5.确保 APT 现在是从设置的仓库中下载Docker<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache policy docker-engine</span><br></pre></td></tr></table></figure></p><p>执行后输出：<br><img src="/assets/images/2018/01/docker1.png" alt=""><br>6.对于Ubuntu 16.04，推荐安装linux-image-extra-* 内核包。这些包能允许我们使用aufs存储驱动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install linux-image-extra-$(uname -r) linux-image-extra-virtual</span><br></pre></td></tr></table></figure></p><h4 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y docker-engine</span><br></pre></td></tr></table></figure><p>开启守护进程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service docker start</span><br></pre></td></tr></table></figure></p><p>确认docker正确安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure></p><p>输出如下：</p><p><img src="/assets/images/2018/01/docker2.png" alt=""></p><p>查看 docker 守护进程的状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status docker</span><br></pre></td></tr></table></figure></p><p>输出如下：</p><p><img src="/assets/images/2018/01/docker3.png" alt=""><br>如果不想每次运行Docker都使用sudo权限，可以把用户加到Docker组中，该组在Docker安装时自动创建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker $(whoami)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍在Ubuntu下Docker的安装。&lt;/p&gt;
&lt;h2 id=&quot;Ubuntu下安装Docker&quot;&gt;&lt;a href=&quot;#Ubuntu下安装Docker&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu下安装Docker&quot;&gt;&lt;/a&gt;Ubuntu下安装Docker&lt;/h2&gt;&lt;h4 id=&quot;检查当前内核版本：&quot;&gt;&lt;a href=&quot;#检查当前内核版本：&quot; class=&quot;headerlink&quot; title=&quot;检查当前内核版本：&quot;&gt;&lt;/a&gt;检查当前内核版本：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ uname -r&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4.14.0-041400-generic&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;内核版本要求最低为 3.10。&lt;/p&gt;
&lt;h4 id=&quot;更新apt源&quot;&gt;&lt;a href=&quot;#更新apt源&quot; class=&quot;headerlink&quot; title=&quot;更新apt源&quot;&gt;&lt;/a&gt;更新apt源&lt;/h4&gt;&lt;p&gt;Docker默认APT仓库中的版本较低，因此要设置APT使用Docker的官方源：&lt;br&gt;1.更新包信息，确保APT能使用https的方式，并安装CA证书：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install apt-transport-https ca-certificates&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://likernel.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker基础</title>
    <link href="http://likernel.github.io/2018/01/31/Docker%E5%9F%BA%E7%A1%80/"/>
    <id>http://likernel.github.io/2018/01/31/Docker基础/</id>
    <published>2018-01-31T04:41:15.000Z</published>
    <updated>2018-02-11T14:49:33.142Z</updated>
    
    <content type="html"><![CDATA[<p>Docker是一个开源的应用程序引擎。Docker使用容器引擎解决平台依赖问题，它在每台宿主机上都启动一个Docker的守护进程，守护进程屏蔽了与具体平台相关的信息，对上层应用提供统一的接口。这样Docker化的应用，就可以在多个平台下运行，Docker会针对不同的平台，解析给不同平台下的执行驱动、存储驱动和网络驱动去执行。达到：</p><blockquote><p>Build once，Run anywhere，Configure once，Run anything.</p></blockquote><a id="more"></a><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>如果把Docker当做一个独立的软件来看，它就是用Golang写的开源程序，采用C/S架构，包含Docker Server和Docker Client。docker生态包括两个部分：Docker仓库和Docker自身程序。</p><h4 id="Docker仓库"><a href="#Docker仓库" class="headerlink" title="Docker仓库"></a>Docker仓库</h4><p>官方的Docker仓库地址为：<a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a>，上面的应用非常丰富，既有各大公司打包的应用，也有大量个人开发者提供的应用。</p><h4 id="Docker自身程序"><a href="#Docker自身程序" class="headerlink" title="Docker自身程序"></a>Docker自身程序</h4><p>Docker运行在Linux操作系统之上，属于用户态程序，通过一些接口和内核交互。Docker Daemon作为Server端，在宿主机上以后台守护进程的形式运行。Docker Client使用比较灵活，既可以在本机上以bin命令的形式发送指令，也可在远端通过RESTful API的形式发送指令；Docker的Server端接受指令并把指令分解为一系列任务去执行。</p><h4 id="Docker工作流程"><a href="#Docker工作流程" class="headerlink" title="Docker工作流程"></a>Docker工作流程</h4><p>一图胜千言：<br><img src="/assets/images/2018/01/docker-liucheng.png" alt=""></p><p>可以理解为github版的应用部署解决方案。</p><h4 id="Docker分层"><a href="#Docker分层" class="headerlink" title="Docker分层"></a>Docker分层</h4><p>首先，用户的需求是：把软件运行起来，至于如何安装软件、软件运行在什么操作系统上，用户不太关心。就把软件和它依赖的环境（操作系统、共享库）、配置文件打包在一起，以虚拟机的形式放到官方库。但是，这样存在一个问题：我们不需要每次安装软件都带上它依赖的操作系统，因此引入了分层。比如操作系统是第一层，依赖库和第三方软件是第二层，应用的软件包和配置文件是第三层。如果两个应用有相同的底层，就可以共享这些库。例如下图中应用A和B需要的操作系统一样，就可以共享这一层。</p><p><img src="/assets/images/2018/01/share-1.png" alt=""><br>但是这样共享层存在冲突问题，这时候就要规定他们的优先级，一般下层和上层有相同的文件和配置时，上层覆盖下层，数据以上层数据为主。我们给每个应用一个优先级最高的空白层，如果需要修改下层文件，就把这个文件拷贝到这个空白层即可。如下图：</p><p><img src="/assets/images/2018/01/conflict.png" alt=""></p><p>这样从应用A的角度来说，文件已经修改成功，而从应用B的角度来看，文件没发生任何变化。这就是Docker的分层和写时拷贝策略</p><h4 id="镜像和容器"><a href="#镜像和容器" class="headerlink" title="镜像和容器"></a>镜像和容器</h4><p>主流的虚拟机一般比较笨重（需要消耗大量的系统资源，如：CPU、内存），因此我们最好使用容器类虚拟机（例如OpenVZ、VServer、LXC），这是一种内核虚拟化技术，与宿主机运行在相同的Linux内核，不需要指令级模拟，性能消耗非常小，是非常轻量级的虚拟化容器。Docker使用的就是LXC（后来推出了libcontainer）。</p><p>接下来就讨论镜像和容器：在Docker的官方仓库里只有一些完整的文件系统和程序包，没有动态生成新文件的需求，此为镜像（image）。把镜像下载到宿主机对外提供服务时，有可能需要修改文件（比如输出新日志到日志文件中），此为容器。</p><p><img src="/assets/images/2018/01/image-container.png" alt=""><br>仓库中的应用都是以镜像的形式存在的，把镜像从Docker仓库拉到本机，以这个镜像为模板启动应用就叫容器。这是Docker最核心的两个概念，所有的指令和文档都是围绕镜像和容器展开的。</p><h4 id="Docker变更管理"><a href="#Docker变更管理" class="headerlink" title="Docker变更管理"></a>Docker变更管理</h4><p>举个栗子，现有一个应用的Docker镜像，V1.0版本有三层。<br>接下来需要做如下修改：</p><ul><li>修改位于第一层的文件A。</li><li>删除位于第二层的文件B。</li><li>新建一个文件C。</li></ul><p>Docker会新建一个第四层，针对上面的修改，它的处理方法如下：</p><ul><li>把第一层的文件A拷贝到第四层，修改文件A的内容。</li><li>在第四层把文件B设置为不存在。</li><li>在第四层创建以个文件C。</li></ul><p>这时候版本就变为了V1.1，我们发布到Docker仓库时，只需要把第四层上传到仓库即可。</p><p><img src="/assets/images/2018/01/version-change.png" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[^1]: 《循序渐进学Docker》李金榜，尹烨等. 编著</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker是一个开源的应用程序引擎。Docker使用容器引擎解决平台依赖问题，它在每台宿主机上都启动一个Docker的守护进程，守护进程屏蔽了与具体平台相关的信息，对上层应用提供统一的接口。这样Docker化的应用，就可以在多个平台下运行，Docker会针对不同的平台，解析给不同平台下的执行驱动、存储驱动和网络驱动去执行。达到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Build once，Run anywhere，Configure once，Run anything.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://likernel.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>PyQt5之信号与槽</title>
    <link href="http://likernel.github.io/2018/01/25/PyQt5%E4%B9%8B%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD/"/>
    <id>http://likernel.github.io/2018/01/25/PyQt5之信号与槽/</id>
    <published>2018-01-25T04:13:52.000Z</published>
    <updated>2018-02-11T14:56:40.466Z</updated>
    
    <content type="html"><![CDATA[<p>PyQt5中最核心的内容就是信号与槽。本文主要结合一个简单的实例对这部分内容进行详细的介绍。<br><a id="more"></a></p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>本文是笔者在学习pyQt5中的学习笔记，需要建立在一定基础之上，如下。</p><ul><li>Python面向对象知识</li><li>了解PyQt5基本操作：布局、常用控件等。</li><li>Qt Designer的使用</li></ul><h2 id="何谓信号与槽"><a href="#何谓信号与槽" class="headerlink" title="何谓信号与槽"></a>何谓信号与槽</h2><p>信号和槽机制是PyQt5的核心机制，主要用来在对象之间传递数据。具体的过程是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">事件发生-&gt;发射signal-&gt;slot响应</span><br></pre></td></tr></table></figure></p><h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><p>当对象的状态发生变化的时候，信号就由对象发射（emit）出去，与其关联的槽函数立刻被执行。</p><p>对象只负责发送信号，不关心是哪个对象接收信号。这样保证了对象与对象之间的低耦合。</p><h4 id="槽"><a href="#槽" class="headerlink" title="槽"></a>槽</h4><p>负责接受信号，当和槽连接的信号被发射时，槽会被调用。一个槽并不知道是否有信号与自己相连。</p><h2 id="如何连接信号与槽"><a href="#如何连接信号与槽" class="headerlink" title="如何连接信号与槽"></a>如何连接信号与槽</h2><p>在Qt Designer中，有很便捷的方法。在Edit中通过Edit Signals/Slots（F4）连接信号与槽。但是这种方式，并不能完全满足我们的需求，很多时候我们需要手动（手写代码）连接信号与槽。</p><h4 id="手动连接信号与槽"><a href="#手动连接信号与槽" class="headerlink" title="手动连接信号与槽"></a>手动连接信号与槽</h4><p>手动连接主要下面三种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.connect(widgets,SIGNAL(&quot;signal&quot;),func)</span><br><span class="line">self.connect(widgets,SIGNAL(&quot;signal&quot;),instance.methodname)</span><br><span class="line">self.connect(widgets,SIGNAL(&quot;signal&quot;),instance,SLOT(&quot;slotSignature&quot;))</span><br></pre></td></tr></table></figure></p><p>##自定义槽函数<br>Qt中的对象有很多预定义的信号和槽函数。但是预定义的槽函数毕竟有限，我们需要自定义槽函数，实现我们的需求。当然可以通过eric自动生成槽函数，但是这种方式主要的逻辑仍然需要自己实现，这里就不介绍。</p><p>举个栗子：这里用自己写的一个岩体分级的工具为例。逻辑非常简单：就是输入一堆参数，得到一个结果，通过结果对岩体进行分级，界面如下。</p><p><img src="/assets/images/2018/01/Qclassify-ui.png" alt=""></p><p>UI设计通过Qt Designer生成。</p><p>逻辑部分和UI部分分离，新建.py文件，创建一个类，继承QMainWindow和QtDesigner生成的UI类Ui_MainWindow。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class MainWindow(QMainWindow, Ui_MainWindow):</span><br><span class="line">    global QRD, Jn, Jr, Ja, Jw, SRF, res,rl</span><br><span class="line">    def __init__(self, parent = None):</span><br><span class="line">        QMainWindow.__init__(self,parent)</span><br><span class="line">        self.setupUi(self)</span><br></pre></td></tr></table></figure></p><p>继承父类Ui_MainWindow的setupUi方法，setupUi方法中通过控件的名字来自动连接槽：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QtCore.QMetaObject.connectSlotsByName(MainWindow)</span><br></pre></td></tr></table></figure></p><p>通过自定义槽函数来实现特定的功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def on_pushButton_clicked(self):</span><br><span class="line">    self.test()</span><br></pre></td></tr></table></figure></p><p>其中test()主要实现具体的逻辑功能，注意这里自定义槽函数的名称要和控件名称（pushButton）对应：on_pushButton\ _clicked。</p><p>通过实例ui的show()方法来显示程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    import sys</span><br><span class="line">    app = QtWidgets.QApplication(sys.argv)</span><br><span class="line">    ui = MainWindow()</span><br><span class="line">    ui.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure></p><p>这里对信号和槽做了粗浅的认识和学习，关于其他内容不再赘述，更多详细内容，可参照官方文档。</p><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p><a href="http://pyqt.sourceforge.net/Docs/PyQt5/index.html" target="_blank" rel="noopener">PyQt5 Reference Guide</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PyQt5中最核心的内容就是信号与槽。本文主要结合一个简单的实例对这部分内容进行详细的介绍。&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://likernel.github.io/tags/python/"/>
    
      <category term="PyQt5" scheme="http://likernel.github.io/tags/PyQt5/"/>
    
  </entry>
  
  <entry>
    <title>PyQt5+Pycharm环境搭建</title>
    <link href="http://likernel.github.io/2018/01/23/PyQt5-Pycharm%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://likernel.github.io/2018/01/23/PyQt5-Pycharm环境搭建/</id>
    <published>2018-01-23T00:35:50.000Z</published>
    <updated>2018-02-11T14:55:56.204Z</updated>
    
    <content type="html"><![CDATA[<p>最近要写一个岩石分级的工具，选择了PyQt5作为GUI开发的框架。本文介绍一下基本的环境的配置。<br><a id="more"></a></p><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><ul><li>Pycharm</li><li>Python 3.6(这里建议使用python3，在虚拟环境中配置)</li><li>PyQt5</li><li>SIP</li><li>Qt Designer<h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><h4 id="安装SIP"><a href="#安装SIP" class="headerlink" title="安装SIP"></a>安装SIP</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install SIP</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>sip是RiverBank（PyQt的开发商）开发的用于PyQt的Python/C++混合编程解决方案。由于Qt框架的复杂性，PyQt并没有使用Cython、SWIG的混合编程方案，而是自己单独做了一套框架。sip包括一个sip工具、SDK和Python Module。</p></blockquote><h4 id="安装PyQt5"><a href="#安装PyQt5" class="headerlink" title="安装PyQt5"></a>安装PyQt5</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install PyQt5</span><br></pre></td></tr></table></figure><h4 id="安装QtDesigner"><a href="#安装QtDesigner" class="headerlink" title="安装QtDesigner"></a>安装QtDesigner</h4><p>QtDesigner在pyqt5-tools这个包里面有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyqt5-tools</span><br></pre></td></tr></table></figure></p><h2 id="Pycharm配置"><a href="#Pycharm配置" class="headerlink" title="Pycharm配置"></a>Pycharm配置</h2><p>这里我们主要在Pycharm里面配置两个扩展工具。QtDesigner和PyUIC，前者是可视化UI编辑工具，后者是将.ui文件转成.py文件的工具。</p><h4 id="QtDesigner配置"><a href="#QtDesigner配置" class="headerlink" title="QtDesigner配置"></a>QtDesigner配置</h4><p>1.Ctrl+Alt+s调出设置-&gt;Tools-&gt;External Tools<br><img src="/assets/images/2018/01/Qt-designer-setting.png" alt=""></p><p>2.添加扩展工具Qt Designer<br><img src="/assets/images/2018/01/Qt-Designer-setting2.png" alt=""><br>Program填写designer.exe所在的路径，在pyqt5-tools包下面。<br>Working directory填写$ProjectFileDir$(项目目录，在Insert Macro…中可以选择)</p><h4 id="PyUIC配置"><a href="#PyUIC配置" class="headerlink" title="PyUIC配置"></a>PyUIC配置</h4><p>同Qt Designer的配置，具体的配置参数如下：<br><img src="/assets/images/2018/01/PyUIC-setting.png" alt=""><br>Program填写python.exe所在的路径（根据你的虚拟环境而定）。<br>Working directory填写$FileDir$(文件目录，在Insert Macro…中可以选择)<br>其中，Arguments的配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-m PyQt5.uic.pyuic  $FileName$ -o $FileNameWithoutExtension$.py</span><br></pre></td></tr></table></figure></p><p>这时候在External tools下可以看到这两个扩展工具。<br><img src="/assets/images/2018/01/external-tools.png" alt=""><br>点击QtDesigner就可以进入QtDesigner界面了，界面设计完成，可以通过PyUIC将设计的UI文件转化成python代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近要写一个岩石分级的工具，选择了PyQt5作为GUI开发的框架。本文介绍一下基本的环境的配置。&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://likernel.github.io/tags/python/"/>
    
      <category term="PyQt5" scheme="http://likernel.github.io/tags/PyQt5/"/>
    
  </entry>
  
  <entry>
    <title>scikit-neuralnetwork安装</title>
    <link href="http://likernel.github.io/2017/12/28/scikit-neuralnetwork%E5%AE%89%E8%A3%85/"/>
    <id>http://likernel.github.io/2017/12/28/scikit-neuralnetwork安装/</id>
    <published>2017-12-27T23:32:48.000Z</published>
    <updated>2018-02-11T14:54:13.499Z</updated>
    
    <content type="html"><![CDATA[<p>scikit-neuralnetwork是一个开源的深度学习的库，scikit-neuralnetwork的接口和设计规范都是参照scikit-learn，之前用过scikit-learn，对它比较熟悉，因此，准备用它作为深度学习的工具。本文主要介绍它的安装过程以及期间可能遇到的一些问题。<br><a id="more"></a></p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>Ubuntu 16.04</li><li>Python 3.5（virtualenv）</li></ul><p>注：选择Linux的原因，由于这些库的开发者在开发的时候用的都是Linux，出问题的话对应的好解决，Windows环境也可以部署，但是稍微麻烦一些。</p><p>Python的版本选择的是3.5，在沙箱环境virtualenv中，使用virtualenv的好处就是方便管理包，出现问题也可以直接删除这个环境，避免不必要的麻烦。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装scikit-neuralnetwork之前需要安装一些依赖（需要依赖的库）。</p><p>1.进入Python的沙箱环境，安装以下依赖。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pip install scikit-learn==0.17</span><br><span class="line">pip install scipy==0.17.0</span><br><span class="line">pip install Theano==0.8.1</span><br><span class="line">pip install git+https://github.com/Lasagne/Lasagne.git@0440814#egg=Lasagne==0.2-dev</span><br><span class="line">sudo pip install -U numpy</span><br><span class="line">pip install -e git+https://github.com/lisa-lab/pylearn2.git=Package</span><br><span class="line">pip install pandas</span><br><span class="line">pip install matplotlib</span><br></pre></td></tr></table></figure></p><p>2.安装scikit-neuralnetwork<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 将scikit-neuralnetwork源码从github上拷贝下来。</span><br><span class="line">git clone https://github.com/aigamedev/scikit-neuralnetwork.git</span><br><span class="line"># 进入scikit-neuralnetwork文件夹</span><br><span class="line">cd scikit-neuralnetwork</span><br><span class="line"># 安装</span><br><span class="line">python setup.py develop</span><br></pre></td></tr></table></figure></p><p>3.测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install nose</span><br><span class="line">nosetests -v sknn.tests</span><br></pre></td></tr></table></figure></p><p>正常情况下，到这一步不出现问题就安装好了。实际情况会遇到很多问题，下面总结一下常见的问题，和解决方案。</p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p>####各种依赖安装出错<br>最常见的是pylearn2。各种module不存在，cannot import等问题。</p><p>解决方案：在测试或者源码安装时，往往会出现上述情况，原因一般是版本的问题。由于网上的很多教程时间比较早，可能他们安装时不会出现这样的问题。因此，这里最好使用推荐的版本。下图是笔者安装时测试没问题的一些版本的包。</p><p><img src="/assets/images/2017/12/libs.png" alt=""></p><p>注：实在想用最新的版本，可以根据相应的问题修改源码（指的是pylearn2等第三方源码安装的），通常情况下是import出问题。</p><h4 id="测试时出现问题"><a href="#测试时出现问题" class="headerlink" title="测试时出现问题"></a>测试时出现问题</h4><p>1.ERROR：no modole named XXX<br>通常是上述包未安装完，可以根据提示安装完对应的包。记住安装完成后，可以通过 <code>pip list/freeze</code> check一下。</p><p>2.ImportError: libmkl_rt.so:cannot open shared object file: No such file or directory.</p><p>mkl是英特尔数学核心函数库，这个.so（shared object）文件就在进行上述测试时需要调用。但是找不到了。需要我们重新配置一番。<br>①进入<a href="https://software.intel.com/en-us/mkl" target="_blank" rel="noopener">官网</a>下载。</p><p>②找到libmkl_rt.so，一般在”/opt/intel/compilers_and_libraries_2018.1.163/linux/mkl/lib“下。“2018.1.163”一般是你下载的版本。可以看到，下面可以找到其所在位置。<br><img src="/content/images/2017/12/mkl.png" width="550px"></p><p>③让系统能找到，这里使用ldconfig方式。<br>在/etc/ld.so.conf.d下创建一个文件mylibs.conf（注意修改其权限为可写的）。编辑文件，将对应的路径添加进去。<br><img src="/assets/images/2017/12/mylib.conf.png" alt=""><br>注：上述路径可以不用添加那么多，这里是当时为了保险起见都加了。</p><p>④<code>sudo ldconfig</code> 重新加载对应的shared libraries。</p><p>⑤可以通过 <code>ldconfig -v</code>check一下安装成功没有。<br><img src="/assets/images/2017/12/ld.png" alt=""></p><p>这个时候再使用 <code>nosetests -v sknn.tests</code> 进行测试就没有问题了。</p><p>3.如遇到其他问题可随时留言。</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>1.首先来个多层神经网络的demo，examples下的plot_mlp.py<br>（官网和github上也是用的这个demo）。<br><img src="/assets/images/2017/12/Figure-1_001.png" alt=""><br>注：需要安装python3-tk，不然会出现上述“ERROR：no modole named XXX”错误。</p><p>2.再来个mnist数据集上的测试，随便找一个bench_mnist.py<br>下面是训练神经网络的过程。<br><img src="/assets/images/2017/12/bench.png" alt=""></p><p>注：这里由于数据量大，没有完全完全跑完，这里只是验证一下。<br>接下来，我们就可以愉快的进行deep learning的学习了。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>官网地址：<br><a href="https://scikit-neuralnetwork.readthedocs.io" target="_blank" rel="noopener">https://scikit-neuralnetwork.readthedocs.io</a></p><p>github地址：<a href="https://github.com/aigamedev/scikit-neuralnetwork" target="_blank" rel="noopener">https://github.com/aigamedev/scikit-neuralnetwork</a></p><p>以上便是scikit-neuralnetwork安装的整个过程，供自己学习记录，欢迎留言和转载（注明出处）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;scikit-neuralnetwork是一个开源的深度学习的库，scikit-neuralnetwork的接口和设计规范都是参照scikit-learn，之前用过scikit-learn，对它比较熟悉，因此，准备用它作为深度学习的工具。本文主要介绍它的安装过程以及期间可能遇到的一些问题。&lt;br&gt;
    
    </summary>
    
    
      <category term="深度学习" scheme="http://likernel.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>NN-神经网络</title>
    <link href="http://likernel.github.io/2017/12/23/NN-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>http://likernel.github.io/2017/12/23/NN-神经网络/</id>
    <published>2017-12-23T07:01:47.000Z</published>
    <updated>2018-02-11T15:15:02.197Z</updated>
    
    <content type="html"><![CDATA[<p>神经网络（Neural Network）是以人脑中的神经网络为启发的，历史上出现过很多不同的版本，其中最著名也是最常用的算法就是在1980提出的backpropagation(反向传播)，也可以称为BP神经网络，它被应用于多层向前神经网络（Multilayer Feed-Forward Neural Network）。<br><a id="more"></a></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>多层向前神经网络由3部分组成，输入层(input layer)，隐藏层(hidden layers)，输出层(output layers)。</p><p><img src="/assets/images/2017/12/BP-NN-2.jpg" alt=""></p><ul><li>每一层由单元（units）组成，我们也可称其为神经节点。</li><li>输入层（input layer）由训练集的实例特征向量传入。</li><li>经过连接点的权重传入下一层，一层的输出是下一层的输入。</li><li>隐藏层（hidden layer）的个数可以是任意的，输入层有一层，输出层有一层。</li><li>上面这幅图称为两层神经网络（输入层不算）。</li><li>作为多层向前神经网络，理论上，如果有足够多的隐藏层，和足够大的训练集，可以模拟出任何方程。</li></ul><h3 id="设计神经网络结构"><a href="#设计神经网络结构" class="headerlink" title="设计神经网络结构"></a>设计神经网络结构</h3><ol><li>使用神经网络训练数据之前，必须先设计神经网络的结构，也就是确定神经网络的层数以及每层的单元个数。</li><li>特征向量在被传入输入层时，通常要先标准化到0，1之间，目的是加速学习的过程。</li><li>离散型变量的可以被编码成：每一个输入单元对应一个特征值可能被赋的值。</li><li>没有特定的规则来说明最好设计多少个隐藏层，往往需要根据实验测试和误差，以及准确度来实验并改进。</li></ol><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>神经网络既可以做分类，也可以解决回归问题，<br>本文主要讨论分类问题。</p><ul><li>二分类：用一个输出单元表示（分别用0和1表示）。</li><li>多于两类：每一个类别用一个输出单元表示。</li></ul><p>所以，一般情况下，输出单元数量，往往等于类别数量。</p><h3 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h3><p>之前介绍的机器学习的一般框架主要是把一组数据分成训练集和测试集两部分。训练集来训练模型。测试集输入进去看结果是不是对的，根据正确率得到一个准确度。</p><p>机器学习中还有一种更常用和科学的方法，交叉验证方法(cross-validation)。下面来介绍一下这种方法。</p><p><img src="/assets/images/2017/12/cross-validation.jpg" alt=""></p><p>前面我们用机器学习的一般框架是把数据分成2份，一份测试集一份数据集。</p><p>交叉验证方法就是把数据分成更多份，比如像上图中分成3份，其中2份当做训练集，1份当做测试集。重复三次，就可以得到3个准确度，做一个均值就得到最终的准确度，这就是交叉验证。实际上可以分成任意的K份，所以这个方法也被称为K-fold cross validation。</p><h3 id="backpropagation算法"><a href="#backpropagation算法" class="headerlink" title="backpropagation算法"></a>backpropagation算法</h3><p>开篇的时候提到神经网络中最常用的算法就是backpropagation，下面是这种BP算法的主要思想:</p><ol><li>通过迭代性处理训练集中的实例。</li><li>对比经过神经网络后输入层预测值（predict value）和真实值（target value）。</li><li>反方向（output-&gt;hidden-&gt;input）来以最小化误差（error）来更新每个连接的权重（weight）。</li></ol><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>数据集、学习率（learning rate）和一个多层向前神经网络。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>一个训练好的神经网络。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>权重（weights）和偏向（bias，每个单元都有这样一个偏向）需要在开始时进行初始化，一般在-1到1或-0.5到0.5之间进行随机初始化。</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>对于一个训练实例X执行以下步骤：</p><ol><li>由输入层，向前传送，具体传递和计算过程见下图：</li></ol><p><img src="/assets/images/2017/12/bp.jpg" alt=""></p><p>$$I_j=\sum_{i}{} w_ij O_i+\theta_j$$</p><p>其中，\(O_j=\frac{1}{1+{e^{-I_j}}}\)</p><p>如上图所示n个单元，加权求和加上一个偏向后得到一个值，再代入上面的非线性转化方程，可以得到输出结果。</p><p>通过这样的方式就能够一步一步正向的计算出最后输出，接下来就是倒推回去修正优化神经网络。</p><p>2.根据误差（error）反向传送。</p><ul><li>输出层：\(E_{rr_j}=O_j(1-O_j)(T_j-O_j)\)</li><li>隐藏层：\(E_{rr_j}=O_j(1-O_j)\sum_{k}{} E_{rr_j} w_{jk}\)</li><li>权重更新：\(w_{ij}(new)=w_{ij}(old)+\Delta w_{ij}\)，其中，\(\Delta w_{ij}=(l)E_{rr_j}O_i\)，l为学习率（learning rate）。</li><li>偏向更新：\(\theta_j(new)=\theta_j(old)+\Delta \theta_j\)，其中，\(\Delta \theta_j=(l)E_{rr_j}O_i\)</li></ul><p>注：上述的更新实际上采用的是一种梯度爬行的方法。</p><p>3.终止条件。</p><ul><li>权重的更新低于某个阈值。</li><li>预测的错误率低于某个阈值。</li><li>达到预设的循环次数。</li></ul><p>实际上最核心的过程就是在不断的更新、优化权重和偏向。以上就是对神经网络的初步认识，为后面的深度学习打下基础，本文完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;神经网络（Neural Network）是以人脑中的神经网络为启发的，历史上出现过很多不同的版本，其中最著名也是最常用的算法就是在1980提出的backpropagation(反向传播)，也可以称为BP神经网络，它被应用于多层向前神经网络（Multilayer Feed-Forward Neural Network）。&lt;br&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://likernel.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="http://likernel.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>KNN-最邻近规则分类</title>
    <link href="http://likernel.github.io/2017/12/23/KNN-%E6%9C%80%E9%82%BB%E8%BF%91%E8%A7%84%E5%88%99%E5%88%86%E7%B1%BB/"/>
    <id>http://likernel.github.io/2017/12/23/KNN-最邻近规则分类/</id>
    <published>2017-12-23T06:59:48.000Z</published>
    <updated>2018-02-11T14:55:07.827Z</updated>
    
    <content type="html"><![CDATA[<p>KNN（K-Nearest Neighbor）是Cover&amp;Hart于1968年提出的一种分类算法，算法思想就是：<br>&gt;<br>1.为判断未知实例的类别，以所有已知类别的实例作为参考点；<br>2.选择参数K；<br>3.计算未知实例与所有已知实例的距离；<br>4.选择最近的K个已知实例；<br>5.根据投票法则，将未知实例归为K个最邻近样本中最多数的类别。</p><a id="more"></a><p>KNN就是这种“近朱者赤，近墨者黑”的思想，它由你的邻居来推断出你的类别。这里仅对以下一些细节进行补充说明。</p><h2 id="距离"><a href="#距离" class="headerlink" title="距离"></a>距离</h2><p>距离的衡量包括：欧式距离、余弦相似度、曼哈顿距离等。</p><p>欧式距离：<br>$$dist(X,Y)=\sqrt{\sum_{i=1}^{n} {(x_i-y_i)}^2}$$</p><p>余弦相似度（Cosine Similarity）：<br>$$sim(X,Y)=\cos\theta=\frac{\vec{x}\cdot \vec{y}}{||x||\cdot||y||}$$</p><p>曼哈顿距离：<br>$$dist(X,Y)=\sqrt{\sum_{i=1}^{n} {|x_i-y_i|}}$$<br>注：对于文本分类来说，使用余弦相似度来计算就比欧式距离更合适。</p><h2 id="关于K"><a href="#关于K" class="headerlink" title="关于K"></a>关于K</h2><p>k值通常是采用交叉检验来确定（以k=1为基准），一般低于训练样本数的平方根。</p><h2 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h2><p>1.优点：简单，易于理解，易于实现，无需估计参数，无需训练。适合对稀有事件进行分类，特别适合于多分类问题。<br>2.缺点：懒惰算法，对测试样本分类时的计算量大，内存开销大。可解释性较差，无法给出决策树那样的规则。</p><h2 id="改进版本"><a href="#改进版本" class="headerlink" title="改进版本"></a>改进版本</h2><p>对距离加权，距离越近，权重越大。例如：1/d。</p><p>本文完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;KNN（K-Nearest Neighbor）是Cover&amp;amp;Hart于1968年提出的一种分类算法，算法思想就是：&lt;br&gt;&amp;gt;&lt;br&gt;1.为判断未知实例的类别，以所有已知类别的实例作为参考点；&lt;br&gt;2.选择参数K；&lt;br&gt;3.计算未知实例与所有已知实例的距离；&lt;br&gt;4.选择最近的K个已知实例；&lt;br&gt;5.根据投票法则，将未知实例归为K个最邻近样本中最多数的类别。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://likernel.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>决策树</title>
    <link href="http://likernel.github.io/2017/12/23/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <id>http://likernel.github.io/2017/12/23/决策树/</id>
    <published>2017-12-23T06:55:35.000Z</published>
    <updated>2018-02-11T14:50:30.001Z</updated>
    
    <content type="html"><![CDATA[<p>决策树（decision tree）又称为判定树，是运用于分类的一种树结构，其中：<br>&gt;<br>1.每个内部节点代表对某一属性的一次测试。<br>2.每条边代表一个测试结果。<br>3.叶节点代表某个类或类的分布。</p><a id="more"></a><p>决策过程需要从根节点开始，测试集中的数据与决策树中的特征节点进行比较，并按照比较结果选择下一比较分支，直到叶子节点作为最终的决策结果。</p><p>实现决策树的核心就是选择属性判断节点，有很多标准，对应的就是不同的算法，最著名的有三个：ID3，C4.5和CART。在介绍之前，先了解一些预备知识。</p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h3><p>信息是个抽象概念。人们常说信息很多，或者信息较少，但很难说清楚信息到底有多少。1948年，香农提出了“信息熵”的概念，才解决了对信息的量化度量问题。</p><blockquote><p>热力学中的热熵是表示分子状态混乱程度的物理量。香农用信息熵的概念来描述信源的不确定度。</p></blockquote><p>一条信息的信息量大小和不确定性有直接的关系。如果信息的不确定性越大，熵的值也就越大。设D为用类别对训练元组进行的划分，则D的熵（entropy）表示为：</p><p>$$Info(D)=-\sum_{i=1}^{m} p_i log_{2}p_i$$</p><p>其中，D为所有事件集合，p为发生概率，m为特征总数。</p><blockquote><p>一般用比特（bit）来衡量信息的多少。当然，如果log不是以2为底，则使用的是其他的单位。</p></blockquote><h3 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h3><p>即信息获取量（information gain），原有信息熵与属性划分后信息熵的差值，具体计算法如下：</p><p>$$gain(A)=Info(D)-Info_A(D)$$</p><p>其中，第二项为将训练元组D按属性A进行划分：</p><p>$$Info_A(D)=\sum_{j=1}^{v} \frac{|D_j|}{|D|} Info(D_j)$$</p><h2 id="决策树归纳算法"><a href="#决策树归纳算法" class="headerlink" title="决策树归纳算法"></a>决策树归纳算法</h2><h3 id="ID3算法"><a href="#ID3算法" class="headerlink" title="ID3算法"></a>ID3算法</h3><p>ID3算法实际上就是在每次需要分裂时，计算每个属性的增益率，然后选择增益率最大的属性进行分裂。</p><h3 id="C4-5算法"><a href="#C4-5算法" class="headerlink" title="C4.5算法"></a>C4.5算法</h3><p> ID3算法存在一个问题，就是偏向于多值属性，例如，如果存在唯一标识属性ID，则ID3会选择它作为分裂属性，这样虽然使得划分充分纯净，但这种划分对分类几乎毫无用处。ID3的后继算法C4.5使用增益率（gain ratio）的信息增益扩充，试图克服这个偏倚。</p><p> C4.5算法首先定义了“分裂信息”，其定义可以表示成：</p><p>$$split\underline{} Info_A(D)=\sum_{j=1}^{v} \frac{|D_j|}{|D|} log_2(\frac{|D_j|}{|D|})$$</p><p>增益率被定义为：</p><p>$$gain\underline{} ratio(A)=\frac{gain}{split\underline{} Info(A)}$$</p><p> C4.5选择具有最大增益率的属性作为分裂属性。</p><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><p>在实际构造决策树时，通常要进行剪枝，主要是为了避免overfitting。剪枝有两种：</p><p>1.先剪枝：在构造过程中，当某个节点满足剪枝条件，则直接停止此分支的构造。<br>2.后剪枝：先构造完成完整的决策树，再通过某些条件遍历树进行剪枝。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>1.优点：直观、便于理解，小规模数据集有效。<br>2.缺点：处理连续变量时效果不好；类别较多时，错误增加较多；可规模性一般。</p><h3 id="一种特殊情况"><a href="#一种特殊情况" class="headerlink" title="一种特殊情况"></a>一种特殊情况</h3><p>在决策树构造过程中可能会出现这种情况：所有属性都作为分裂属性用完了，但有的子集还不是纯净集，即集合内的元素不属于同一类别。在这种情况下，一般采取“多数表决”，即使用此子集中出现次数最多的类别作为此节点类别，然后将此节点作为叶子节点。</p><p>关于决策树的概念先介绍这么多，具体实例和应用，会有后续文章讲解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;决策树（decision tree）又称为判定树，是运用于分类的一种树结构，其中：&lt;br&gt;&amp;gt;&lt;br&gt;1.每个内部节点代表对某一属性的一次测试。&lt;br&gt;2.每条边代表一个测试结果。&lt;br&gt;3.叶节点代表某个类或类的分布。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://likernel.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基本概念</title>
    <link href="http://likernel.github.io/2017/12/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://likernel.github.io/2017/12/23/机器学习基本概念/</id>
    <published>2017-12-23T04:46:00.000Z</published>
    <updated>2018-02-11T14:52:05.161Z</updated>
    
    <content type="html"><![CDATA[<p>由于论文需要，需要学习一下机器学习相关的知识，本文主要作为抛砖引玉，介绍机器学习的一些基础概念。<br><a id="more"></a></p><h2 id="概念学习"><a href="#概念学习" class="headerlink" title="概念学习"></a>概念学习</h2><blockquote><p>概念学习是指从有关某个布尔函数的输入输出训练样例中推断出该布尔函数，可以表示为：X-&gt;Y/C(x)。</p></blockquote><p>X：实例集，概念就是基于这个实例集的。<br>x：具体的实例。<br>C(x)：待学习的目标概念/函数。</p><p>###训练集和测试集<br>训练集：用来进行训练，产生模型/算法的数据集。</p><p>测试集：用来测试已经学习好的模型或算法。</p><h3 id="特征向量和标记"><a href="#特征向量和标记" class="headerlink" title="特征向量和标记"></a>特征向量和标记</h3><p>特征向量：属性的集合，通常用一个向量表示，附属于一个实例(x)。</p><p>标记：C(x)，实例类别的标记。</p><h3 id="正例和反例"><a href="#正例和反例" class="headerlink" title="正例和反例"></a>正例和反例</h3><p>正例：目标概念的成员。</p><p>反例：非目标概念的成员。</p><h2 id="分类和回归"><a href="#分类和回归" class="headerlink" title="分类和回归"></a>分类和回归</h2><p>分类和回归在机器学习中是很重要的两个领域，暂且先做如下简单的解释，不做深入的探讨。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>分类（classification）的目标标记（label）为类别性数据（离散型）。</p><h3 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h3><p>回归（regression）的目标标记（label）为连续性数值。</p><p>##有监督、无监督和半监督学习<br>机器学习主要分为三类：有监督学习、无监督学习和半监督学习。</p><h3 id="有监督学习"><a href="#有监督学习" class="headerlink" title="有监督学习"></a>有监督学习</h3><p>训练集<strong>有类别标记</strong>（即数据中包含分类的结果）。计算机进行学习之后，在丢给它新的数据，它能够算出结果。可以理解为“在类别标记的监督下进行学习”。</p><p>主要包括：分类和回归。</p><h3 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h3><p>训练集<strong>无类别标记</strong>。单纯凭借计算机强大的计算能力分析数据的特征，得出结果，通常是得到一些集合，集合内的数据在某些特征上相同或相似。可以理解为“没有在类别标记的监督下进行学习”。</p><p>主要包括：聚类。</p><h3 id="半监督学习"><a href="#半监督学习" class="headerlink" title="半监督学习"></a>半监督学习</h3><p>训练集<strong>一部分有类别标记，一部分没有类别标记</strong>。无类别标记的数据量往往远远大于有有标记的数据。<br>可以通过一些有类别标记的数据局部特征，和没类别标记数据的整体分布，得到可以接受甚至是非常好的分类结果。</p><p>主要包括：分类、回归、聚类和降维。</p><h2 id="机器学习一般步骤"><a href="#机器学习一般步骤" class="headerlink" title="机器学习一般步骤"></a>机器学习一般步骤</h2><p>这里不做详细的阐述，只列举一般的机器学习的步骤：</p><h3 id="1-问题定义"><a href="#1-问题定义" class="headerlink" title="1.问题定义"></a>1.问题定义</h3><p>通过观察类别确定究竟是分类还是回归问题。</p><h3 id="2-样本划分"><a href="#2-样本划分" class="headerlink" title="2.样本划分"></a>2.样本划分</h3><p>将数据划分为训练集和测试集。</p><h3 id="3-训练算法"><a href="#3-训练算法" class="headerlink" title="3.训练算法"></a>3.训练算法</h3><p>用训练集和训练集的特征向量训练算法。</p><h3 id="4-评估算法"><a href="#4-评估算法" class="headerlink" title="4.评估算法"></a>4.评估算法</h3><p>用学习来的算法用在测试集。其中，涉及调参和优化（调参还涉及到验证集）这里不做赘述。</p><p>本文主要起到一个抛砖引玉，为后面的学习，梳理一些基本的概念，本文完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于论文需要，需要学习一下机器学习相关的知识，本文主要作为抛砖引玉，介绍机器学习的一些基础概念。&lt;br&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://likernel.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Linux启动流程</title>
    <link href="http://likernel.github.io/2017/09/01/Linux%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>http://likernel.github.io/2017/09/01/Linux启动流程/</id>
    <published>2017-08-31T21:25:09.000Z</published>
    <updated>2018-02-11T15:49:19.116Z</updated>
    
    <content type="html"><![CDATA[<p>之前介绍过计算机的启动流程，我们在此基础上继续介绍Linux的启动流程。<br><a id="more"></a></p><p>#1.加载BIOS<br>当你打开计算机电源，计算机会首先加载BIOS信息，BIOS信息是如此的重要，以至于计算机必须在最开始就找到它。这是因为BIOS中包含了CPU的相关信息、设备启动顺序信息、硬盘信息、内存信息、时钟信息、PnP特性等等。在此之后，计算机心里就有谱了，知道应该去读取哪个硬件设备了。</p><p>#2.读取MBR<br>众所周知，硬盘上第0磁道第一个扇区被称为MBR，也就是Master Boot Record，即<strong>主引导记录</strong>，它的大小是512字节，别看地方不大，可里面却存放了预启动信息、分区表信息。</p><p>系统找到BIOS所指定的硬盘的MBR后，就会将其复制到0x7c00地址所在的物理内存中。其实被复制到物理内存的内容就是Boot Loader，而具体到你的电脑，那就是lilo或者grub了。</p><p>#3.Boot Loader<br>Boot Loader 就是在操作系统内核运行之前运行的一段小程序。通过这段小程序，我们可以初始化硬件设备、建立内存空间的映射图，从而将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统内核做好一切准备。</p><p>Boot Loader有若干种，其中Grub、Lilo和spfdisk是常见的Loader。我们以Grub为例：</p><p>系统读取内存中的grub配置信息（一般为menu.lst或grub.lst），并依照此配置信息来启动不同的操作系统。</p><p>#4.加载内核<br>操作系统接管硬件以后，首先读入 /boot 目录下的内核文件，如下：</p><p><img src="/assets/images/2017/09/----.png" alt=""></p><p>根据grub设定的内核映像所在路径，系统读取内存映像，并进行解压缩操作。此时，屏幕一般会输出“Uncompressing Linux”的提示。当解压缩内核完成后，屏幕输出“OK, booting the kernel”。</p><p>系统将解压后的内核放置在内存之中，并调用start_kernel()函数来启动一系列的初始化函数并初始化各种设备，完成Linux核心环境的建立。至此，Linux内核已经建立起来了，基于Linux的程序应该可以正常运行了。</p><p>#5.启动初始化进程并确定运行级别<br>内核被加载后，第一个运行的程序便是/sbin/init，它的进程编号（pid）就是1。其他所有进程都从它衍生，都是它的子进程。该文件会读取/etc/inittab文件，并依据此文件来进行初始化工作。</p><p>其实/etc/inittab文件最主要的作用就是设定Linux的运行等级，其设定形式是“：id:5:initdefault:”，这就表明Linux需要运行在等级5上。运行等级相关内容在之前有过详细介绍。</p><p>#6.init进程执行rc.sysinit<br>在设定了运行等级后，Linux系统执行的第一个用户层文件就是/etc/rc.d/rc.sysinit脚本程序，它做的工作非常多，包括设定PATH、设定网络配置（/etc/sysconfig/network）、启动swap分区、设定/proc等等。</p><p>#7.启动内核模块<br>具体是依据/etc/modules.conf文件或/etc/modules.d目录下的文件来装载内核模块。</p><p>#8.执行不同运行级别的脚本程序<br>根据运行级别的不同，系统会运行rc0.d到rc6.d中的相应的脚本程序，来完成相应的初始化工作和启动相应的服务，如下：</p><p><img src="/assets/images/2017/09/rcd.png" alt=""></p><p>上面目录名中的”rc”，表示run command（运行程序），最后的d表示directory（目录）。下面让我们看看 /etc/rc2.d 目录中到底指定了哪些程序。</p><p><img src="/assets/images/2017/09/rc2.png" alt=""></p><p>可以看到，除了第一个文件README以外，其他文件名都是”字母S+两位数字+程序名”的形式。字母S表示Start，也就是启动的意思（启动脚本的运行参数为start），如果这个位置是字母K，就代表Kill（关闭），即如果从其他运行级别切换过来，需要关闭的程序（启动脚本的运行参数为stop）。后面的两位数字表示处理顺序，数字越小越早处理，所以第一个启动的程序是motd，然后是rpcbing、nfs……数字相同时，则按照程序名的字母顺序启动，所以rsyslog会先于sudo启动。</p><p>这个目录里的所有文件（除了README），就是启动时要加载的程序。如果想增加或删除某些程序，不建议手动修改 /etc/rcN.d 目录，最好是用一些专门命令进行管理。</p><p>#9.执行/etc/rc.d/rc.local<br>你如果打开了此文件，里面有一句话，读过之后，你就会对此命令的作用一目了然：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># This script will be executed *after* all the other init scripts.</span><br><span class="line"># You can put your own initialization stuff in here if you don’t</span><br><span class="line"># want to do the full Sys V style init stuff.</span><br></pre></td></tr></table></figure></p><p>rc.local就是在一切初始化工作后，Linux留给用户进行个性化的地方。你可以把你想设置和启动的东西放到这里。</p><p>#10.执行/bin/login程序，进入登录状态<br>输入用户名密码登录成功后，系统会为用户分配一个用户 ID（UID），和一个组 ID（GID）。这两个 ID 就好像身份证一样会一直伴随用户，用于检测用户执行程序时的身份验证。</p><p>当用户登录成功后，一个完整的操作系统就展现在用户的面前了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前介绍过计算机的启动流程，我们在此基础上继续介绍Linux的启动流程。&lt;br&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://likernel.github.io/tags/Linux/"/>
    
      <category term="操作系统" scheme="http://likernel.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>计算机启动流程</title>
    <link href="http://likernel.github.io/2017/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>http://likernel.github.io/2017/09/01/计算机启动流程/</id>
    <published>2017-08-31T20:58:22.000Z</published>
    <updated>2018-02-11T15:47:40.158Z</updated>
    
    <content type="html"><![CDATA[<p>计算机的启动是一个非常复杂的过程，在介绍Linux启动流程之前，有必要先了解一下计算机的启动流程。<br><a id="more"></a><br>我们都知道计算机的启动叫做boot，这个名称来源于一句谚语：</p><blockquote><p>　“pull oneself up by one’s bootstraps”<br>字面意思是”拽着鞋带把自己拉起来”，这当是不可能的事情。</p></blockquote><p>最早的时候，工程师们用它来比喻计算机的启动，计算机启动是一个很矛盾的过程：必须先运行程序，然后计算机才能启动，但是计算机不启动就无法运行程序。</p><p>早期真的是这样，必须想尽各种办法，把一小段程序装进内存，然后计算机才能正常运行。所以，工程师们把这个过程叫做”拉鞋带”，久而久之就简称为boot了。</p><p>计算机的整个启动过程分成四个阶段。</p><h1 id="第一阶段：BIOS"><a href="#第一阶段：BIOS" class="headerlink" title="第一阶段：BIOS"></a>第一阶段：BIOS</h1><p>上个世纪70年代初，”只读内存”（read-only memory，缩写为ROM）发明，开机程序被刷入ROM芯片，计算机通电后，第一件事就是读取它。</p><p>这块芯片里的程序叫做”基本输出输入系统”（Basic Input/Output System），简称为BIOS。</p><h2 id="硬件自检"><a href="#硬件自检" class="headerlink" title="硬件自检"></a>硬件自检</h2><p>BIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做”硬件自检”（Power-On Self-Test），缩写为POST。<br>如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。</p><h2 id="启动顺序"><a href="#启动顺序" class="headerlink" title="启动顺序"></a>启动顺序</h2><p>硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序。<br>这时，BIOS需要知道，”下一阶段的启动程序”具体存放在哪一个设备。也就是说，BIOS需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做”启动顺序”（Boot Sequence）。打开BIOS的操作界面，里面有一项就是”设定启动顺序”。我们在装系统的时候经常会设置这一个选项，例如，将U盘作为启动盘的时候，将U盘启动的顺序设为第一启动。</p><p>#第二阶段：主引导记录<br>BIOS按照”启动顺序”，把控制权转交给排在第一位的储存设备。<br>这时，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给”启动顺序”中的下一个设备。<br>这最前面的512个字节，就叫做”主引导记录”（Master boot record，缩写为MBR）。</p><h2 id="主引导记录的结构"><a href="#主引导记录的结构" class="headerlink" title="主引导记录的结构"></a>主引导记录的结构</h2><p>“主引导记录”只有512个字节，放不了太多东西。它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统。<br>主引导记录由三个部分组成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1） 第1-446字节：调用操作系统的机器码。</span><br><span class="line">（2） 第447-510字节：分区表（Partition table）。</span><br><span class="line">（3） 第511-512字节：主引导记录签名（0x55和0xAA）。</span><br></pre></td></tr></table></figure></p><p>其中，第二部分”分区表”的作用，是将硬盘分成若干个区。</p><h2 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h2><p>硬盘分区有很多好处。考虑到每个区可以安装不同的操作系统，”主引导记录”因此必须知道将控制权转交给哪个区。</p><p>分区表的长度只有64个字节，里面又分成四项，每项16个字节。所以，一个硬盘最多只能分四个一级分区，又叫做”主分区”。<br>每个主分区的16个字节，由6个部分组成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1） 第1个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。</span><br><span class="line">（2） 第2-4个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）。</span><br><span class="line">（3） 第5个字节：主分区类型。</span><br><span class="line">（4） 第6-8个字节：主分区最后一个扇区的物理位置。</span><br><span class="line">（5） 第9-12字节：该主分区第一个扇区的逻辑地址。</span><br><span class="line">（6） 第13-16字节：主分区的扇区总数。</span><br></pre></td></tr></table></figure></p><p>最后的四个字节（”主分区的扇区总数”），决定了这个主分区的长度。也就是说，一个主分区的扇区总数最多不超过2的32次方。</p><p>如果每个扇区为512个字节，就意味着单个分区最大不超过2TB。再考虑到扇区的逻辑地址也是32位，所以单个硬盘可利用的空间最大也不超过2TB。如果想使用更大的硬盘，只有2个方法：一是提高每个扇区的字节数，二是增加扇区总数。</p><p>#第三阶段：硬盘启动<br>这时，计算机的控制权就要转交给硬盘的某个分区了，这里又分成三种情况。</p><p>##情况A：卷引导记录<br>上一节提到，四个主分区里面，只有一个是激活的。计算机会读取激活分区的第一个扇区，叫做”卷引导记录”（Volume boot record，缩写为VBR）。</p><p>“卷引导记录”的主要作用是，告诉计算机，操作系统在这个分区里的位置。然后，计算机就会加载操作系统了。</p><p>##情况B：扩展分区和逻辑分区<br>随着硬盘越来越大，四个主分区已经不够了，需要更多的分区。但是，分区表只有四项，因此规定有且仅有一个区可以被定义成”扩展分区”（Extended partition）。<br>所谓”扩展分区”，就是指这个区里面又分成多个区。这种分区里面的分区，就叫做”逻辑分区”（logical partition）。</p><p>计算机先读取扩展分区的第一个扇区，叫做”扩展引导记录”（Extended boot record，缩写为EBR）。它里面也包含一张64字节的分区表，但是最多只有两项（也就是两个逻辑分区）。</p><p>计算机接着读取第二个逻辑分区的第一个扇区，再从里面的分区表中找到第三个逻辑分区的位置，以此类推，直到某个逻辑分区的分区表只包含它自身为止（即只有一个分区项）。因此，扩展分区可以包含无数个逻辑分区。</p><p>但是，似乎很少通过这种方式启动操作系统。如果操作系统确实安装在扩展分区，一般采用下一种方式启动。</p><p>##情况C：启动管理器<br>在这种情况下，计算机读取”主引导记录”前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的”启动管理器”（boot loader），由用户选择启动哪一个操作系统。</p><p>Linux环境中，目前最流行的启动管理器是Grub。</p><p>#第四阶段：操作系统<br>控制权转交给操作系统后，操作系统的内核首先被载入内存。<br>以Linux系统为例，先载入/boot目录下面的kernel。内核加载成功后，第一个运行的程序是/sbin/init。它根据配置文件（Debian系统是/etc/initab）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代。</p><p>然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行/bin/login程序，跳出登录界面，等待用户输入用户名和密码。至此，全部启动过程完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机的启动是一个非常复杂的过程，在介绍Linux启动流程之前，有必要先了解一下计算机的启动流程。&lt;br&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://likernel.github.io/tags/Linux/"/>
    
      <category term="操作系统" scheme="http://likernel.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统运行级别</title>
    <link href="http://likernel.github.io/2017/08/31/Linux%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB/"/>
    <id>http://likernel.github.io/2017/08/31/Linux系统运行级别/</id>
    <published>2017-08-31T06:35:59.000Z</published>
    <updated>2018-02-11T15:48:43.791Z</updated>
    
    <content type="html"><![CDATA[<p>运行级别（Runlevel）指的是Unix或者Linux等类Unix操作系统的运行模式，不同的运行模式下系统的功能也有所有不同。Linux系统下通常分为7种运行级别，分别是从0到6。各级别介绍如下：<br><a id="more"></a></p><p>#7种运行级别</p><p>##运行级别0<br><strong>停机模式。</strong>在这种模式下，系统处于停机状态，系统默认运行级别不能设为0，否则将不能正常启动。这个运行级别主要用于关闭任务，在/etc/rc0.d目录下的各个连接命令都是此级别的命令，在关闭系统时，这些命令将被逐个执行。它们会杀掉所有进程、关闭虚拟内存和交换文件、卸载文件系统和交换分区。</p><p>##运行级别1<br><strong>单用户模式。</strong>在这种运行模下，系统处于单用户工作状态，登录用户具有root权限，文件系统被加载但是网络却没有被加载，因此也无法远程登陆。<br>这个运行级别，只允一个用户从本地计算机上登录，/etc/rc1.d目录下的所有文件与此运行级别相关连，这个运行级别一般用于系统管理与维护。</p><p>##运行级别2<br><strong>多用户模式。</strong>用户可以通过网络进行登录，但没有NFS（Network File System），即网络文件系统。/etc/rc2.d目录下所有文件与此级别相连。</p><p>##运行级别3<br><strong>完全多用户模式。</strong>用户可以通过网络进行登录，且有NFS，用户登陆后会进入控制台命令行模式。这也是缺省的运行模式，在这种运行级别下所有网络服务程序会一起运行。/etc/rc2.d录下的文件与此级别相连。</p><p>##运行级别4<br><strong>自定义模式。</strong>这是一种系统未使用的保留模式，/etc/rc4.d目录与此级别相连。这一级别是用户自定义的运行级别，用户可以根自己的需要进行一些自定义设置。如果想要运行这一级别的话，必须在rc3.d目录下放入连接文件，就像其他rc*.d目录下的文件，并指明是启动还是终止进程。</p><p>##运行级别5<br><strong>图形化模式。</strong>在 Linux 下运行X Window就是使用这一运行级别，用户登录后将进入图形化的GUI界面。在这一级别下除了DNS的named与级别3不同，其余的都相同。</p><p>##运行级别6<br><strong>重启模式。</strong>系统正常关闭并重启，默认运行级别不能设为5，否则系统将不能正常启动。/etc/rc6.d目录与此级别相连。在这一运行级别下，不会关闭电源，/etc/rc6.d目录下的连接与rc0.d目录下的连接基本相同；不同之处在于，虽然它们都执行halt（关闭）命令，但是给halt传递的参数不同，所级别6会重新启动系统而0会关闭系统。</p><p>注意：以上适用于CentOS等发行版，而对于Ubuntu等debian系的Linux来说，2~5都是多用户图形模式，几个运行模式没有区别。</p><p>#不同运行级别的实现原理<br>如上所述，Linux系统的每一个运行级别，都对应一个目录。</p><p>在/etc/init.d目录下有许多脚本程序，我们将这些程序称之为服务(Service)。</p><p>而/etc目录下，还有rc0.d~rc6.d共7个目录。在这些目录下都是一些软链接文件，这些链接文件都指向了init.d目录下的service脚本文件。而这些软连接的命名规则为：K+nn+服务名或S+nn+服务名，其中nn为两位数字。</p><p>系统启动时，会根据当前运行级别进入对应的rc*.d目录，然后按照文件名顺序检索目录下的链接文件，并会做以下处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于以K开头的文件，系统将终止对应的服务</span><br><span class="line">对于以S开头的文件，系统将启动对应的服务</span><br></pre></td></tr></table></figure></p><p>注意：/etc/init.d存在于Ubuntu等发行版中，而CentOS等发行版中位于/etc/rc.d/init.d目录下，但通过/etc/init.d软连接进行关联。同样的，rc*.d等目录，在Ubuntu等系统中位于/etc/目录下，而在CentOS等系统中位于/etc/rc.d目录下，但在/etc下都有对应的软连接。</p><p>#Linux运行级别的修改</p><p>##运行级别相关命令<br>查看系统当前运行级别：runlevel<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ runlevel</span><br><span class="line">N 3</span><br></pre></td></tr></table></figure></p><p>切换系统运行级别：init N。如，切换到3多用户命令模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init 3</span><br></pre></td></tr></table></figure></p><p>常用的init命令还有：init 0结束所有进程后关闭计算机、init 6重启系统</p><p>##修改系统默认运行级别<br>Linux 会根据运行级别的不同执行不同程序，虽然Ubuntu和CenosOS等不同发行版中都有运行级别的概念，但运行机制不同，因此修改默认启动级别的方式也有所有不同。</p><p>这里以CentOS为例：</p><p>CentOS等Linux系统中使用一种叫System V的机制来启动运行级别，在该机制下，通过/etc/inittab配置系统启动进程。因此，也可以通过该文件来配置默认的启动级别：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi /etc/inittab</span><br></pre></td></tr></table></figure></p><p>找到如下行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id:5:initdefault:</span><br></pre></td></tr></table></figure></p><p>并修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id:3:initdefault:</span><br></pre></td></tr></table></figure></p><p>注意：以上方法适用于CentOS 7之前的系统，在CentOS 7中/etc/inittab文件已不再使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/inittab</span><br><span class="line"># inittab is no longer used when using systemd.</span><br><span class="line">#</span><br><span class="line"># ADDING CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.</span><br><span class="line">#</span><br><span class="line"># Ctrl-Alt-Delete is handled by /usr/lib/systemd/system/ctrl-alt-del.target</span><br><span class="line">#</span><br><span class="line"># systemd uses &apos;targets&apos; instead of runlevels. By default, there are two main targets:</span><br><span class="line">#</span><br><span class="line"># multi-user.target: analogous to runlevel 3</span><br><span class="line"># graphical.target: analogous to runlevel 5</span><br><span class="line">#</span><br><span class="line"># To view current default target, run:</span><br><span class="line"># systemctl get-default</span><br><span class="line">#</span><br><span class="line"># To set a default target, run:</span><br><span class="line"># systemctl set-default TARGET.target</span><br><span class="line">#</span><br></pre></td></tr></table></figure></p><p>根据该文件提示，查看当前启动模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl get-default</span><br><span class="line">graphical.target</span><br></pre></td></tr></table></figure></p><p>修改默认启动级别：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl set-default multi-user.target</span><br></pre></td></tr></table></figure></p><p>输入密码完成修改。重启后，系统默认将以级别3启动。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;运行级别（Runlevel）指的是Unix或者Linux等类Unix操作系统的运行模式，不同的运行模式下系统的功能也有所有不同。Linux系统下通常分为7种运行级别，分别是从0到6。各级别介绍如下：&lt;br&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://likernel.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>su和su -的区别</title>
    <link href="http://likernel.github.io/2017/08/31/su%E5%92%8Csu-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://likernel.github.io/2017/08/31/su和su-的区别/</id>
    <published>2017-08-30T21:56:21.000Z</published>
    <updated>2018-02-11T15:48:13.638Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍一下，su和su -的区别。<br><a id="more"></a></p><p>#su命令实例<br>当不加任何参数执行su命令时，表示要切换到root用户，但这样执行，会遇到一些问题。因为虽然是切换到root用户了，但并没有改变为root用户登录环境，用户默认的登录环境，可以在/etc/passwd 中查得到，包括家目录，shell类型等。比较规范的操作方法是“su -“，见下面的实例。</p><p>实例：由普通用户likernel切换到root用户</p><p><strong>使用su：</strong></p><p><img src="/assets/images/2017/08/su.png" alt=""></p><p>可以看到，如果使用su而不加上“-”这个参数，那么，切换前的用户的相关信息还会存在，这会引起很多麻烦，甚至会出现意想不到的结果。因此，切换用户时，最好是 “su - 用户名”。这是生产场景中标准的切换用户的操作方法。</p><p><strong>使用su -：</strong></p><p><img src="/assets/images/2017/08/su--.png" alt=""><br>这次和上次就不同了，所有的环境变量信息都切换到了root下。因此，请大家在切换用户时一定要加上“su - 用户名”。注意，不光是切到root，切换到其他用户也是一样。</p><p>#su命令总结：</p><p>1）普通用户切换到root用户，可使用su -或su - root。必须输入root密码才能完成切换。</p><p>2）root用户切换到普通用户，可使用“su - 普通用户名”的写法。不需要输入任何密码就能完成切换。切换到普通用户后，在执行一些命令如ifconfig时，可能会遭遇到环境变量PATH路径问题而找不到某些系统命令（一般是/sbin，/usr/sbin等下面的命令），这时就需要将普通用户的PATH，配置成root的PATH内容。</p><p>3）如果仅希望在某用户下执行命令，而不直接切换到该用户下操作，可以使用 su - 用户名 -c “命令”的方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍一下，su和su -的区别。&lt;br&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://likernel.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode--Reverse Linked List</title>
    <link href="http://likernel.github.io/2017/08/23/Leetcode-Reverse-Linked-List/"/>
    <id>http://likernel.github.io/2017/08/23/Leetcode-Reverse-Linked-List/</id>
    <published>2017-08-23T00:06:53.000Z</published>
    <updated>2018-02-11T14:44:31.256Z</updated>
    
    <content type="html"><![CDATA[<p>翻转单链表。<br><a id="more"></a><br>链表的操作，关键就在指针。当然使用栈很容易实现，但是我们有更好的方法，就是借助三个指针。</p><p>pre：当前元素的前一个元素的指针<br>cur：当前元素的指针<br>nextp：当前元素的下一个元素的指针</p><p><strong>实现：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode(object):</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.next = None</span><br><span class="line"></span><br><span class="line">class Solution(object):</span><br><span class="line">    def reverseList(self, head):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        pre = None</span><br><span class="line">        cur = head</span><br><span class="line"></span><br><span class="line">        while cur != None:</span><br><span class="line">            nextp = cur.next</span><br><span class="line"></span><br><span class="line">            cur.next = pre   #翻转操作</span><br><span class="line"></span><br><span class="line">            pre = cur</span><br><span class="line">            cur = nextp      </span><br><span class="line">        return pre</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻转单链表。&lt;br&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://likernel.github.io/tags/leetcode/"/>
    
      <category term="算法" scheme="http://likernel.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="http://likernel.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Python读取文件</title>
    <link href="http://likernel.github.io/2017/08/21/Python%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6/"/>
    <id>http://likernel.github.io/2017/08/21/Python读取文件/</id>
    <published>2017-08-21T06:58:16.000Z</published>
    <updated>2018-02-11T15:38:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>python中读取文件常用的三种方法：read(),readline(),readlines()。在做笔试题的时候被这个东西卡了半天，遂总结一下。<br><a id="more"></a><br>假设a.txt的内容如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This is line1.</span><br><span class="line">This is line2.</span><br><span class="line">This is line3.</span><br></pre></td></tr></table></figure></p><p>#read()<br>语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read([size])</span><br></pre></td></tr></table></figure></p><p>从文件当前位置起读取size个字节，若无参数size，则表示读取至文件结束为止，它范围为字符串对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = open(&quot;a.txt&quot;)</span><br><span class="line">lines = f.read()</span><br><span class="line">print lines</span><br><span class="line">print(type(lines))</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">This is line1.</span><br><span class="line">This is line2.</span><br><span class="line">This is line3.</span><br><span class="line">&lt;type &apos;str&apos;&gt; #字符串类型</span><br></pre></td></tr></table></figure></p><h1 id="readline"><a href="#readline" class="headerlink" title="readline()"></a>readline()</h1><p>该方法每次读出一行内容，所以，读取时占用内存小，比较适合大文件，该方法返回一个字符串对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f = open(&quot;a.txt&quot;)</span><br><span class="line">line = f.readline()</span><br><span class="line">print(type(line))</span><br><span class="line">while line:</span><br><span class="line">    print line,</span><br><span class="line">    line = f.readline()</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;type &apos;str&apos;&gt;</span><br><span class="line">This is line1.</span><br><span class="line">This is line2.</span><br><span class="line">This is line3.</span><br></pre></td></tr></table></figure></p><p>#readlines()<br>读取整个文件所有行，保存在一个列表(list)变量中，每行作为一个元素，但读取大文件会比较占内存。<br>f = open(“a.txt”)<br>lines = f.readlines()<br>print(type(lines))<br>for line in lines:<br>    print line，<br>f.close()<br>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;type &apos;list&apos;&gt;</span><br><span class="line">This is line1.</span><br><span class="line">This is line2.</span><br><span class="line">This is line3.</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python中读取文件常用的三种方法：read(),readline(),readlines()。在做笔试题的时候被这个东西卡了半天，遂总结一下。&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://likernel.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python函数式编程</title>
    <link href="http://likernel.github.io/2017/08/17/Python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://likernel.github.io/2017/08/17/Python函数式编程/</id>
    <published>2017-08-17T03:15:34.000Z</published>
    <updated>2018-02-11T15:38:10.642Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍一下Python函数式编程的基本概念。<br><a id="more"></a></p><h1 id="命令式编程"><a href="#命令式编程" class="headerlink" title="命令式编程"></a>命令式编程</h1><p>首先从大家熟悉的命令式编程开始，我们先回顾下平时在写代码时主要的情景。</p><p>其实，不管我们的业务代码有多复杂，都离不开以下几类操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.函数定义：def</span><br><span class="line">2.条件控制：if, elif, else</span><br><span class="line">3.循环控制：for, break, continue, while</span><br></pre></td></tr></table></figure></p><p>当然，这只是部分操作类型，除此之外还应该有类和模块、异常处理等等。但考虑到是入门，我们就先只关注上面这三种最常见的操作。</p><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>对应地，函数式编程也有自己的关键字。在Python语言中，用于函数式编程的主要由3个基本函数和1个算子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.基本函数：map()、reduce()、filter()</span><br><span class="line">2.算子(operator)：lambda</span><br></pre></td></tr></table></figure></p><p>令人惊讶的是，仅仅采用这几个函数和算子就基本上可以实现任意Python程序。</p><p>当然，能实现是一回事儿，实际编码时是否这么写又是另外一回事儿。估计要真只采用这几个基本单元来写所有代码的话，不管是在表达上还是在阅读上应该都挺别扭的。不过，尝试采用这几个基本单元来替代上述的函数定义、条件控制、循环控制等操作，对理解函数式编程如何通过函数和递归表达流程控制应该会很有帮助。</p><h1 id="替换条件控制语句"><a href="#替换条件控制语句" class="headerlink" title="替换条件控制语句"></a>替换条件控制语句</h1><p>在对条件控制进行替换之前，我们先来回顾下Python中对布尔表达式求值时进行的“短路”处理。</p><p>什么叫“短路”处理？简单地讲，就是如下两点：</p><p>1.在f(x) and g(y)中，当f(x)为false时，不会再执行g(y)，直接返回false<br>2.在f(x) or g(y)中，当f(x)为true时，不会再执行g(y)，直接返回true<br>结论是显然易现的，就不再过多解释。</p><p>那么，对应到条件控制语句，我们不难理解，如下条件控制语句和表达式是等价的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># flow control statement</span><br><span class="line">if &lt;cond1&gt;:   func1()</span><br><span class="line">elif &lt;cond2&gt;: func2()</span><br><span class="line">else:         func3()</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Equivalent &quot;short circuit&quot; expression</span><br><span class="line">(&lt;cond1&gt; and func1()) or (&lt;cond2&gt; and func2()) or (func3())</span><br></pre></td></tr></table></figure><p>通过这个等价替换，我们就去除掉了if/elif/else关键词，将条件控制语句转换为一个表达式。而lambda算子返回的就是一个表达式。</p><p>基于这一点，我们就可以采用lambda创建如下函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pr = lambda s:s</span><br><span class="line">&gt;&gt;&gt; print_num = lambda x: (x==1 and pr(&quot;one&quot;))</span><br><span class="line">....                  or (x==2 and pr(&quot;two&quot;))</span><br><span class="line">....                  or (pr(&quot;other&quot;))</span><br><span class="line">&gt;&gt;&gt; print_num(1)</span><br><span class="line">&apos;one&apos;</span><br><span class="line">&gt;&gt;&gt; print_num(2)</span><br><span class="line">&apos;two&apos;</span><br><span class="line">&gt;&gt;&gt; print_num(3)</span><br><span class="line">&apos;other&apos;</span><br></pre></td></tr></table></figure></p><p>通过函数调用的结果可以看到，以上函数实现的功能与之前的条件控制语句实现的功能完全相同。</p><p>到这里，我们就实现了命令式条件控制语句向函数式语句的转换。并且这个转换的方法是通用的，所有条件控制语句都可以采用这种方式转换为函数式语句。</p><h1 id="替换循环控制语句"><a href="#替换循环控制语句" class="headerlink" title="替换循环控制语句"></a>替换循环控制语句</h1><p>接下来我们再看循环控制语句的转换。在Python中，循环控制是通过for和while这两种方式实现的。</p><p>##替换for循环</p><p>for循环语句的替换十分简单，采用map()函数就能轻松实现。这主要是因为for语句和map()原理相同，都是对可迭代对象里面的每一个元素进行操作，因此转换过程比较自然。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># statement-based for loop</span><br><span class="line">for e in lst:  func(e)</span><br><span class="line"></span><br><span class="line"># Equivalent map()-based loop</span><br><span class="line">map(func, lst)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; square = lambda x : x * x</span><br><span class="line">&gt;&gt;&gt; for x in [1,2,3,4,5]: square(x)</span><br><span class="line">...</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">9</span><br><span class="line">16</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; map(square, [1,2,3,4,5])</span><br><span class="line">[1, 4, 9, 16, 25]</span><br></pre></td></tr></table></figure><h2 id="替换while循环"><a href="#替换while循环" class="headerlink" title="替换while循环"></a>替换while循环</h2><p>while循环语句的替换相比而言就复杂了许多。</p><p>下面分别是while循环语句及其对应的函数式风格的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># statement-based while loop</span><br><span class="line">while &lt;condition&gt;:</span><br><span class="line">    &lt;pre-suite&gt;</span><br><span class="line">    if &lt;break_condition&gt;:</span><br><span class="line">        break</span><br><span class="line">    else:</span><br><span class="line">        &lt;suite&gt;</span><br><span class="line"></span><br><span class="line"># Equivalent FP-style recursive while loop</span><br><span class="line">def while_block():</span><br><span class="line">    &lt;pre-suite&gt;</span><br><span class="line">    if &lt;break_condition&gt;:</span><br><span class="line">        return 1</span><br><span class="line">    else:</span><br><span class="line">        &lt;suite&gt;</span><br><span class="line">    return 0</span><br><span class="line"></span><br><span class="line">while_FP = lambda: &lt;condition&gt; and (while_block() or while_FP())</span><br><span class="line">while_FP()</span><br></pre></td></tr></table></figure></p><p>这里的难点在于，函数式while_FP循环采用了递归的概念。当为true时，进入循环体，执行while_block()；若为true时，返回1，while_FP()调用结束；若为false时，返回0，会继续执行or右侧的while_FP()，从而实现递归调用；若始终为false，则会持续递归调用while_FP()，这就实现了while语句中同样的功能。</p><p>为了对函数式的while循环有更深刻的理解，可以再看下如下示例。这个例子是在网上找的，实现的是echo功能：输入任意非”quit”字符时，打印输入的字符；输入”quit”字符时，退出程序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  PythonFP python pyecho.py</span><br><span class="line">IMP -- 1</span><br><span class="line">1</span><br><span class="line">IMP -- 2</span><br><span class="line">2</span><br><span class="line">IMP -- abc</span><br><span class="line">abc</span><br><span class="line">IMP -- 1 + 1</span><br><span class="line">1 + 1</span><br><span class="line">IMP -- quit</span><br><span class="line">quit</span><br><span class="line">➜  PythonFP</span><br></pre></td></tr></table></figure></p><p>如下便是分别采用过程式和函数式语句实现的”echo”功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># imperative version of &quot;echo()&quot;</span><br><span class="line">def echo_IMP():</span><br><span class="line">    while 1:</span><br><span class="line">        x = raw_input(&quot;IMP -- &quot;)</span><br><span class="line">        print x</span><br><span class="line">        if x == &apos;quit&apos;:</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line">echo_IMP()</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def monadic_print(x):</span><br><span class="line">    print x</span><br><span class="line">    return x</span><br><span class="line"></span><br><span class="line"># FP version of &quot;echo()&quot;</span><br><span class="line">echo_FP = lambda: monadic_print(raw_input(&quot;FP -- &quot;))==&apos;quit&apos; or echo_FP()</span><br><span class="line">echo_FP()</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[^1]: (Python的函数式编程，从入门到放弃) <a href="http://python.jobbole.com/84927/" target="_blank" rel="noopener"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍一下Python函数式编程的基本概念。&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://likernel.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>filter()</title>
    <link href="http://likernel.github.io/2017/08/17/filter/"/>
    <id>http://likernel.github.io/2017/08/17/filter/</id>
    <published>2017-08-17T03:06:00.000Z</published>
    <updated>2018-02-09T07:36:06.164Z</updated>
    
    <content type="html"><![CDATA[<p>Python内建的filter()函数用于过滤序列。<br><a id="more"></a><br>和map()类似，filter()也接收一个函数和一个序列。和map()不同的时，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。</p><p>例如，在一个list中，删掉偶数，只保留奇数，可以这么写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def is_odd(n):</span><br><span class="line">    return n % 2 == 1</span><br><span class="line"></span><br><span class="line">filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15])</span><br><span class="line"># 结果: [1, 5, 9, 15]</span><br></pre></td></tr></table></figure></p><p>把一个序列中的空字符串删掉，可以这么写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def not_empty(s):</span><br><span class="line">    return s and s.strip()</span><br><span class="line"></span><br><span class="line">filter(not_empty, [&apos;A&apos;, &apos;&apos;, &apos;B&apos;, None, &apos;C&apos;, &apos;  &apos;])</span><br><span class="line"># 结果: [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]</span><br></pre></td></tr></table></figure></p><p>可见用filter()这个高阶函数，关键在于正确实现一个“筛选”函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python内建的filter()函数用于过滤序列。&lt;br&gt;
    
    </summary>
    
    
      <category term=" - python" scheme="http://likernel.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>map() and reduce()</title>
    <link href="http://likernel.github.io/2017/08/17/map-and-reduce/"/>
    <id>http://likernel.github.io/2017/08/17/map-and-reduce/</id>
    <published>2017-08-17T02:48:44.000Z</published>
    <updated>2018-02-11T15:40:05.208Z</updated>
    
    <content type="html"><![CDATA[<p>Python内建了map()和reduce()函数。<br><a id="more"></a></p><h1 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h1><p>map()函数的常见调用形式如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map(func, iterable)</span><br></pre></td></tr></table></figure></p><p>map()需要两个必填参数，第一个参数是一个函数名，第二个参数是一个可迭代的对象，如列表、元组等。</p><p>map()实现的功能很简单，就是将第二个参数（iterable）中的每一个元素分别传给第一个参数（func），依次执行函数得到结果，并将结果组成一个新的list对象后进行返回。返回结果永远都是一个list。</p><p>简单示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; double_func = lambda s : s * 2</span><br><span class="line">&gt;&gt;&gt; map(double_func, [1,2,3,4,5])</span><br><span class="line">[2, 4, 6, 8, 10]</span><br></pre></td></tr></table></figure></p><p>除了传入一个可迭代对象这种常见的模式外，map()还支持传入多个可迭代对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map(func, iterable1, iterable2)</span><br></pre></td></tr></table></figure></p><p>在传入多个可迭代对象的情况下，map()会依次从所有可迭代对象中依次取一个元素，组成一个元组列表，然后将元组依次传给func；若可迭代对象的长度不一致，则会以None进行补上。</p><p>通过以下示例应该就比较容易理解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; plus = lambda x,y : (x or 0) + (y or 0)</span><br><span class="line">&gt;&gt;&gt; map(plus, [1,2,3], [4,5,6])</span><br><span class="line">[5, 7, 9]</span><br><span class="line">&gt;&gt;&gt; map(plus, [1,2,3,4], [4,5,6])</span><br><span class="line">[5, 7, 9, 4]</span><br><span class="line">&gt;&gt;&gt; map(plus, [1,2,3], [4,5,6,7])</span><br><span class="line">[5, 7, 9, 7]</span><br></pre></td></tr></table></figure></p><p>在上面的例子中，之所以采用x or 0的形式，是为了防止None + int出现异常。</p><p>需要注意的是，可迭代对象的个数应该与func的参数个数一致，否则就会出现异常，因为传参个数与函数参数个数不一致了，这个应该比较好理解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; plus = lambda x,y : x + y</span><br><span class="line">&gt;&gt;&gt; map(plus, [1,2,3])</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: &lt;lambda&gt;() takes exactly 2 arguments (1 given)</span><br></pre></td></tr></table></figure></p><p>另外，map()还存在一种特殊情况，就是func为None。这个时候，map()仍然是从所有可迭代对象中依次取一个元素，组成一个元组列表，然后将这个元组列表作为结果进行返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; map(None, [1,2,3,4])</span><br><span class="line">[1, 2, 3, 4]</span><br><span class="line">&gt;&gt;&gt; map(None, [1,2,3,4], [5,6,7,8])</span><br><span class="line">[(1, 5), (2, 6), (3, 7), (4, 8)]</span><br><span class="line">&gt;&gt;&gt; map(None, [1,2,3,4], [5,6,7])</span><br><span class="line">[(1, 5), (2, 6), (3, 7), (4, None)]</span><br><span class="line">&gt;&gt;&gt; map(None, [1,2,3,4], [6,7,8,9], [11,12])</span><br><span class="line">[(1, 6, 11), (2, 7, 12), (3, 8, None), (4, 9, None)]</span><br></pre></td></tr></table></figure></p><h1 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h1><p>reduce()函数的调用形式如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(func, iterable[, initializer])</span><br></pre></td></tr></table></figure></p><p>reduce()函数的功能是对可迭代对象（iterable）中的元素从左到右进行累计运算，最终得到一个数值。第三个参数initializer是初始数值，可以空置，空置为None时就从可迭代对象（iterable）的第二个元素开始，并将第一个元素作为之前的结果。</p><p>看下reduce()的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def reduce(function, iterable, initializer=None):</span><br><span class="line">    it = iter(iterable)</span><br><span class="line">    if initializer is None:</span><br><span class="line">        try:</span><br><span class="line">            initializer = next(it)</span><br><span class="line">        except StopIteration:</span><br><span class="line">            raise TypeError(&apos;reduce() of empty sequence with no initial value&apos;)</span><br><span class="line">    accum_value = initializer</span><br><span class="line">    for x in it:</span><br><span class="line">        accum_value = function(accum_value, x)</span><br><span class="line">    return accum_value</span><br></pre></td></tr></table></figure></p><p>再加上如下示例，对reduce()的功能应该就能掌握了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; plus = lambda x, y : x + y</span><br><span class="line">&gt;&gt;&gt; reduce(plus, [1,2,3,4,5])</span><br><span class="line">15</span><br><span class="line">&gt;&gt;&gt; reduce(plus, [1,2,3,4,5], 10)</span><br><span class="line">25</span><br></pre></td></tr></table></figure></p><p>配合map()，我们就可以写出把str转换为int的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def fn(x, y):</span><br><span class="line">...     return x * 10 + y</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; def char2num(s):</span><br><span class="line">...     return &#123;&apos;0&apos;: 0, &apos;1&apos;: 1, &apos;2&apos;: 2, &apos;3&apos;: 3, &apos;4&apos;: 4, &apos;5&apos;: 5, &apos;6&apos;: 6, &apos;7&apos;: 7, &apos;8&apos;: 8, &apos;9&apos;: 9&#125;[s]</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; reduce(fn, map(char2num, &apos;13579&apos;))</span><br><span class="line">13579</span><br></pre></td></tr></table></figure></p><p>整理成一个str2int的函数就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def str2int(s):</span><br><span class="line">    def fn(x, y):</span><br><span class="line">        return x * 10 + y</span><br><span class="line">    def char2num(s):</span><br><span class="line">        return &#123;&apos;0&apos;: 0, &apos;1&apos;: 1, &apos;2&apos;: 2, &apos;3&apos;: 3, &apos;4&apos;: 4, &apos;5&apos;: 5, &apos;6&apos;: 6, &apos;7&apos;: 7, &apos;8&apos;: 8, &apos;9&apos;: 9&#125;[s]</span><br><span class="line">    return reduce(fn, map(char2num, s))</span><br></pre></td></tr></table></figure></p><p>还可以用lambda函数进一步简化成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def char2num(s):</span><br><span class="line">    return &#123;&apos;0&apos;: 0, &apos;1&apos;: 1, &apos;2&apos;: 2, &apos;3&apos;: 3, &apos;4&apos;: 4, &apos;5&apos;: 5, &apos;6&apos;: 6, &apos;7&apos;: 7, &apos;8&apos;: 8, &apos;9&apos;: 9&#125;[s]</span><br><span class="line"></span><br><span class="line">def str2int(s):</span><br><span class="line">    return reduce(lambda x,y: x*10+y, map(char2num, s))</span><br></pre></td></tr></table></figure></p><p>也就是说，假设Python没有提供int()函数，你完全可以自己写一个把字符串转化为整数的函数，而且只需要几行代码！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python内建了map()和reduce()函数。&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://likernel.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python协程</title>
    <link href="http://likernel.github.io/2017/08/17/Python%E5%8D%8F%E7%A8%8B/"/>
    <id>http://likernel.github.io/2017/08/17/Python协程/</id>
    <published>2017-08-17T02:22:10.000Z</published>
    <updated>2018-02-11T15:36:15.198Z</updated>
    
    <content type="html"><![CDATA[<p>协程，又称微线程，纤程。英文名Coroutine。<br><a id="more"></a><br>子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。</p><p>所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。</p><p>子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。</p><p>协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p><p>注意，在一个子程序中中断，去执行其他子程序，不是函数调用，有点类似CPU的中断。比如子程序A、B：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def A():</span><br><span class="line">    print &apos;1&apos;</span><br><span class="line">    print &apos;2&apos;</span><br><span class="line">    print &apos;3&apos;</span><br><span class="line"></span><br><span class="line">def B():</span><br><span class="line">    print &apos;x&apos;</span><br><span class="line">    print &apos;y&apos;</span><br><span class="line">    print &apos;z&apos;</span><br></pre></td></tr></table></figure></p><p>假设由协程执行，在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A，结果可能是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">x</span><br><span class="line">y</span><br><span class="line">3</span><br><span class="line">z</span><br></pre></td></tr></table></figure></p><p>但是在A中是没有调用B的，所以协程的调用比函数调用理解起来要难一些。</p><p>看起来A、B的执行有点像多线程，但协程的特点在于是一个线程执行，那和多线程比，协程有何优势？</p><p>最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p><p>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p><p>因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</p><p>Python对协程的支持还非常有限，用在generator中的yield可以一定程度上实现协程。虽然支持不完全，但已经可以发挥相当大的威力了。</p><p>来看例子：</p><p>传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。</p><p>如果改用协程，生产者生产消息后，直接通过yield跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def consumer():</span><br><span class="line">    r = &apos;&apos;</span><br><span class="line">    while True:</span><br><span class="line">        n = yield r</span><br><span class="line">        if not n:</span><br><span class="line">            return</span><br><span class="line">        print(&apos;[CONSUMER] Consuming %s...&apos; % n)</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        r = &apos;200 OK&apos;</span><br><span class="line"></span><br><span class="line">def produce(c):</span><br><span class="line">    c.next()</span><br><span class="line">    n = 0</span><br><span class="line">    while n &lt; 5:</span><br><span class="line">        n = n + 1</span><br><span class="line">        print(&apos;[PRODUCER] Producing %s...&apos; % n)</span><br><span class="line">        r = c.send(n)</span><br><span class="line">        print(&apos;[PRODUCER] Consumer return: %s&apos; % r)</span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    c = consumer()</span><br><span class="line">    produce(c)</span><br></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[PRODUCER] Producing 1...</span><br><span class="line">[CONSUMER] Consuming 1...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 2...</span><br><span class="line">[CONSUMER] Consuming 2...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 3...</span><br><span class="line">[CONSUMER] Consuming 3...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 4...</span><br><span class="line">[CONSUMER] Consuming 4...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 5...</span><br><span class="line">[CONSUMER] Consuming 5...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br></pre></td></tr></table></figure></p><p>注意到consumer函数是一个generator（生成器），把一个consumer传入produce后：<br>首先调用c.next()启动生成器；然后，一旦生产了东西，通过c.send(n)切换到consumer执行；consumer通过yield拿到消息，处理，又通过yield把结果传回；produce拿到consumer处理的结果，继续生产下一条消息；produce决定不生产了，通过c.close()关闭consumer，整个过程结束。</p><p>整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务。</p><p>最后套用Donald Knuth的一句话总结协程的特点：</p><blockquote><p>“子程序就是协程的一种特例。”</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;协程，又称微线程，纤程。英文名Coroutine。&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://likernel.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python切片</title>
    <link href="http://likernel.github.io/2017/08/17/Python%E5%88%87%E7%89%87/"/>
    <id>http://likernel.github.io/2017/08/17/Python切片/</id>
    <published>2017-08-17T01:13:59.000Z</published>
    <updated>2018-02-11T15:37:08.790Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍一下Python切片。<br><a id="more"></a><br>取一个list或tuple的部分元素是非常常见的操作。Python提供了切片（Slice）操作符，能大大简化这种操作。例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;, &apos;Bob&apos;, &apos;Jack&apos;]</span><br></pre></td></tr></table></figure></p><p>取前3个元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[0:3]</span><br><span class="line">[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;]</span><br></pre></td></tr></table></figure></p><p>L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。</p><p>如果第一个索引是0，还可以省略：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[:3]</span><br><span class="line">[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;]</span><br></pre></td></tr></table></figure></p><p>也可以从索引1开始，取出2个元素出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[1:3]</span><br><span class="line">[&apos;Sarah&apos;, &apos;Tracy&apos;]</span><br></pre></td></tr></table></figure></p><p>类似的，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[-2:]</span><br><span class="line">[&apos;Bob&apos;, &apos;Jack&apos;]</span><br><span class="line">&gt;&gt;&gt; L[-2:-1]</span><br><span class="line">[&apos;Bob&apos;]</span><br></pre></td></tr></table></figure></p><p>记住倒数第一个元素的索引是-1。</p><p>切片操作十分有用。我们先创建一个0-99的数列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = range(100)</span><br><span class="line">&gt;&gt;&gt; L</span><br><span class="line">[0, 1, 2, 3, ..., 99]</span><br></pre></td></tr></table></figure></p><p>可以通过切片轻松取出某一段数列。比如前10个数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[:10]</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure></p><p>后10个数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[-10:]</span><br><span class="line">[90, 91, 92, 93, 94, 95, 96, 97, 98, 99]</span><br></pre></td></tr></table></figure></p><p>前11-20个数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[10:20]</span><br><span class="line">[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</span><br></pre></td></tr></table></figure></p><p>前10个数，每两个取一个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[:10:2]</span><br><span class="line">[0, 2, 4, 6, 8]</span><br></pre></td></tr></table></figure></p><p>所有数，每5个取一个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[::5]</span><br><span class="line">[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]</span><br></pre></td></tr></table></figure></p><p>甚至什么都不写，只写[:]就可以原样复制一个list：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[:]</span><br><span class="line">[0, 1, 2, 3, ..., 99]</span><br></pre></td></tr></table></figure></p><p>tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; (0, 1, 2, 3, 4, 5)[:3]</span><br><span class="line">(0, 1, 2)</span><br></pre></td></tr></table></figure></p><p>字符串’xxx’或Unicode字符串u’xxx’也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;ABCDEFG&apos;[:3]</span><br><span class="line">&apos;ABC&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;ABCDEFG&apos;[::2]</span><br><span class="line">&apos;ACEG&apos;</span><br></pre></td></tr></table></figure></p><p>在很多编程语言中，针对字符串提供了很多各种截取函数，其实目的就是对字符串切片。Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>有了切片操作，很多地方循环就不再需要了。Python的切片非常灵活，一行代码就可以实现很多行循环才能完成的操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍一下Python切片。&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://likernel.github.io/tags/python/"/>
    
  </entry>
  
</feed>
