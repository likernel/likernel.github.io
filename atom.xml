<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>likernel</title>
  <icon>https://www.gravatar.com/avatar/d0e54b3b2e11646353dba604f4cd06d9</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://likernel.github.io/"/>
  <updated>2018-02-11T14:46:28.577Z</updated>
  <id>http://likernel.github.io/</id>
  
  <author>
    <name>likernel</name>
    <email>daqingv5@foxmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ubuntu下安装Docker</title>
    <link href="http://likernel.github.io/2018/01/31/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85Docker/"/>
    <id>http://likernel.github.io/2018/01/31/Ubuntu下安装Docker/</id>
    <published>2018-01-31T08:51:27.000Z</published>
    <updated>2018-02-11T14:46:28.577Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍在Ubuntu下Docker的安装。</p><h2 id="Ubuntu下安装Docker"><a href="#Ubuntu下安装Docker" class="headerlink" title="Ubuntu下安装Docker"></a>Ubuntu下安装Docker</h2><h4 id="检查当前内核版本："><a href="#检查当前内核版本：" class="headerlink" title="检查当前内核版本："></a>检查当前内核版本：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ uname -r</span><br><span class="line">4.14.0-041400-generic</span><br></pre></td></tr></table></figure><p>内核版本要求最低为 3.10。</p><h4 id="更新apt源"><a href="#更新apt源" class="headerlink" title="更新apt源"></a>更新apt源</h4><p>Docker默认APT仓库中的版本较低，因此要设置APT使用Docker的官方源：<br>1.更新包信息，确保APT能使用https的方式，并安装CA证书：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install apt-transport-https ca-certificates</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>2.添加GPG密钥：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D</span><br></pre></td></tr></table></figure></p><p>3.在文件 /etc/apt/sources.list.d/docker.list中添加相应的源。对于16.04版本的系统：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;deb https://apt.dockerproject.org/repo ubuntu-xenial main&quot; | sudo tee /etc/apt/sources.list.d/docker.list</span><br></pre></td></tr></table></figure></p><p>4.更新APT包索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></p><p>5.确保 APT 现在是从设置的仓库中下载Docker<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache policy docker-engine</span><br></pre></td></tr></table></figure></p><p>执行后输出：<br><img src="/assets/images/2018/01/docker1.png" alt=""><br>6.对于Ubuntu 16.04，推荐安装linux-image-extra-* 内核包。这些包能允许我们使用aufs存储驱动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install linux-image-extra-$(uname -r) linux-image-extra-virtual</span><br></pre></td></tr></table></figure></p><h4 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y docker-engine</span><br></pre></td></tr></table></figure><p>开启守护进程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service docker start</span><br></pre></td></tr></table></figure></p><p>确认docker正确安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure></p><p>输出如下：</p><p><img src="/assets/images/2018/01/docker2.png" alt=""></p><p>查看 docker 守护进程的状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status docker</span><br></pre></td></tr></table></figure></p><p>输出如下：</p><p><img src="/assets/images/2018/01/docker3.png" alt=""><br>如果不想每次运行Docker都使用sudo权限，可以把用户加到Docker组中，该组在Docker安装时自动创建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker $(whoami)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍在Ubuntu下Docker的安装。&lt;/p&gt;
&lt;h2 id=&quot;Ubuntu下安装Docker&quot;&gt;&lt;a href=&quot;#Ubuntu下安装Docker&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu下安装Docker&quot;&gt;&lt;/a&gt;Ubuntu下安装Docker&lt;/h2&gt;&lt;h4 id=&quot;检查当前内核版本：&quot;&gt;&lt;a href=&quot;#检查当前内核版本：&quot; class=&quot;headerlink&quot; title=&quot;检查当前内核版本：&quot;&gt;&lt;/a&gt;检查当前内核版本：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ uname -r&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4.14.0-041400-generic&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;内核版本要求最低为 3.10。&lt;/p&gt;
&lt;h4 id=&quot;更新apt源&quot;&gt;&lt;a href=&quot;#更新apt源&quot; class=&quot;headerlink&quot; title=&quot;更新apt源&quot;&gt;&lt;/a&gt;更新apt源&lt;/h4&gt;&lt;p&gt;Docker默认APT仓库中的版本较低，因此要设置APT使用Docker的官方源：&lt;br&gt;1.更新包信息，确保APT能使用https的方式，并安装CA证书：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install apt-transport-https ca-certificates&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://likernel.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker基础</title>
    <link href="http://likernel.github.io/2018/01/31/Docker%E5%9F%BA%E7%A1%80/"/>
    <id>http://likernel.github.io/2018/01/31/Docker基础/</id>
    <published>2018-01-31T04:41:15.000Z</published>
    <updated>2018-02-11T14:49:33.142Z</updated>
    
    <content type="html"><![CDATA[<p>Docker是一个开源的应用程序引擎。Docker使用容器引擎解决平台依赖问题，它在每台宿主机上都启动一个Docker的守护进程，守护进程屏蔽了与具体平台相关的信息，对上层应用提供统一的接口。这样Docker化的应用，就可以在多个平台下运行，Docker会针对不同的平台，解析给不同平台下的执行驱动、存储驱动和网络驱动去执行。达到：</p><blockquote><p>Build once，Run anywhere，Configure once，Run anything.</p></blockquote><a id="more"></a><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>如果把Docker当做一个独立的软件来看，它就是用Golang写的开源程序，采用C/S架构，包含Docker Server和Docker Client。docker生态包括两个部分：Docker仓库和Docker自身程序。</p><h4 id="Docker仓库"><a href="#Docker仓库" class="headerlink" title="Docker仓库"></a>Docker仓库</h4><p>官方的Docker仓库地址为：<a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a>，上面的应用非常丰富，既有各大公司打包的应用，也有大量个人开发者提供的应用。</p><h4 id="Docker自身程序"><a href="#Docker自身程序" class="headerlink" title="Docker自身程序"></a>Docker自身程序</h4><p>Docker运行在Linux操作系统之上，属于用户态程序，通过一些接口和内核交互。Docker Daemon作为Server端，在宿主机上以后台守护进程的形式运行。Docker Client使用比较灵活，既可以在本机上以bin命令的形式发送指令，也可在远端通过RESTful API的形式发送指令；Docker的Server端接受指令并把指令分解为一系列任务去执行。</p><h4 id="Docker工作流程"><a href="#Docker工作流程" class="headerlink" title="Docker工作流程"></a>Docker工作流程</h4><p>一图胜千言：<br><img src="/assets/images/2018/01/docker-liucheng.png" alt=""></p><p>可以理解为github版的应用部署解决方案。</p><h4 id="Docker分层"><a href="#Docker分层" class="headerlink" title="Docker分层"></a>Docker分层</h4><p>首先，用户的需求是：把软件运行起来，至于如何安装软件、软件运行在什么操作系统上，用户不太关心。就把软件和它依赖的环境（操作系统、共享库）、配置文件打包在一起，以虚拟机的形式放到官方库。但是，这样存在一个问题：我们不需要每次安装软件都带上它依赖的操作系统，因此引入了分层。比如操作系统是第一层，依赖库和第三方软件是第二层，应用的软件包和配置文件是第三层。如果两个应用有相同的底层，就可以共享这些库。例如下图中应用A和B需要的操作系统一样，就可以共享这一层。</p><p><img src="/assets/images/2018/01/share-1.png" alt=""><br>但是这样共享层存在冲突问题，这时候就要规定他们的优先级，一般下层和上层有相同的文件和配置时，上层覆盖下层，数据以上层数据为主。我们给每个应用一个优先级最高的空白层，如果需要修改下层文件，就把这个文件拷贝到这个空白层即可。如下图：</p><p><img src="/assets/images/2018/01/conflict.png" alt=""></p><p>这样从应用A的角度来说，文件已经修改成功，而从应用B的角度来看，文件没发生任何变化。这就是Docker的分层和写时拷贝策略</p><h4 id="镜像和容器"><a href="#镜像和容器" class="headerlink" title="镜像和容器"></a>镜像和容器</h4><p>主流的虚拟机一般比较笨重（需要消耗大量的系统资源，如：CPU、内存），因此我们最好使用容器类虚拟机（例如OpenVZ、VServer、LXC），这是一种内核虚拟化技术，与宿主机运行在相同的Linux内核，不需要指令级模拟，性能消耗非常小，是非常轻量级的虚拟化容器。Docker使用的就是LXC（后来推出了libcontainer）。</p><p>接下来就讨论镜像和容器：在Docker的官方仓库里只有一些完整的文件系统和程序包，没有动态生成新文件的需求，此为镜像（image）。把镜像下载到宿主机对外提供服务时，有可能需要修改文件（比如输出新日志到日志文件中），此为容器。</p><p><img src="/assets/images/2018/01/image-container.png" alt=""><br>仓库中的应用都是以镜像的形式存在的，把镜像从Docker仓库拉到本机，以这个镜像为模板启动应用就叫容器。这是Docker最核心的两个概念，所有的指令和文档都是围绕镜像和容器展开的。</p><h4 id="Docker变更管理"><a href="#Docker变更管理" class="headerlink" title="Docker变更管理"></a>Docker变更管理</h4><p>举个栗子，现有一个应用的Docker镜像，V1.0版本有三层。<br>接下来需要做如下修改：</p><ul><li>修改位于第一层的文件A。</li><li>删除位于第二层的文件B。</li><li>新建一个文件C。</li></ul><p>Docker会新建一个第四层，针对上面的修改，它的处理方法如下：</p><ul><li>把第一层的文件A拷贝到第四层，修改文件A的内容。</li><li>在第四层把文件B设置为不存在。</li><li>在第四层创建以个文件C。</li></ul><p>这时候版本就变为了V1.1，我们发布到Docker仓库时，只需要把第四层上传到仓库即可。</p><p><img src="/assets/images/2018/01/version-change.png" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[^1]: 《循序渐进学Docker》李金榜，尹烨等. 编著</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker是一个开源的应用程序引擎。Docker使用容器引擎解决平台依赖问题，它在每台宿主机上都启动一个Docker的守护进程，守护进程屏蔽了与具体平台相关的信息，对上层应用提供统一的接口。这样Docker化的应用，就可以在多个平台下运行，Docker会针对不同的平台，解析给不同平台下的执行驱动、存储驱动和网络驱动去执行。达到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Build once，Run anywhere，Configure once，Run anything.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://likernel.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>PyQt5之信号与槽</title>
    <link href="http://likernel.github.io/2018/01/25/PyQt5%E4%B9%8B%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD/"/>
    <id>http://likernel.github.io/2018/01/25/PyQt5之信号与槽/</id>
    <published>2018-01-25T04:13:52.000Z</published>
    <updated>2018-02-11T14:56:40.466Z</updated>
    
    <content type="html"><![CDATA[<p>PyQt5中最核心的内容就是信号与槽。本文主要结合一个简单的实例对这部分内容进行详细的介绍。<br><a id="more"></a></p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>本文是笔者在学习pyQt5中的学习笔记，需要建立在一定基础之上，如下。</p><ul><li>Python面向对象知识</li><li>了解PyQt5基本操作：布局、常用控件等。</li><li>Qt Designer的使用</li></ul><h2 id="何谓信号与槽"><a href="#何谓信号与槽" class="headerlink" title="何谓信号与槽"></a>何谓信号与槽</h2><p>信号和槽机制是PyQt5的核心机制，主要用来在对象之间传递数据。具体的过程是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">事件发生-&gt;发射signal-&gt;slot响应</span><br></pre></td></tr></table></figure></p><h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><p>当对象的状态发生变化的时候，信号就由对象发射（emit）出去，与其关联的槽函数立刻被执行。</p><p>对象只负责发送信号，不关心是哪个对象接收信号。这样保证了对象与对象之间的低耦合。</p><h4 id="槽"><a href="#槽" class="headerlink" title="槽"></a>槽</h4><p>负责接受信号，当和槽连接的信号被发射时，槽会被调用。一个槽并不知道是否有信号与自己相连。</p><h2 id="如何连接信号与槽"><a href="#如何连接信号与槽" class="headerlink" title="如何连接信号与槽"></a>如何连接信号与槽</h2><p>在Qt Designer中，有很便捷的方法。在Edit中通过Edit Signals/Slots（F4）连接信号与槽。但是这种方式，并不能完全满足我们的需求，很多时候我们需要手动（手写代码）连接信号与槽。</p><h4 id="手动连接信号与槽"><a href="#手动连接信号与槽" class="headerlink" title="手动连接信号与槽"></a>手动连接信号与槽</h4><p>手动连接主要下面三种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.connect(widgets,SIGNAL(&quot;signal&quot;),func)</span><br><span class="line">self.connect(widgets,SIGNAL(&quot;signal&quot;),instance.methodname)</span><br><span class="line">self.connect(widgets,SIGNAL(&quot;signal&quot;),instance,SLOT(&quot;slotSignature&quot;))</span><br></pre></td></tr></table></figure></p><p>##自定义槽函数<br>Qt中的对象有很多预定义的信号和槽函数。但是预定义的槽函数毕竟有限，我们需要自定义槽函数，实现我们的需求。当然可以通过eric自动生成槽函数，但是这种方式主要的逻辑仍然需要自己实现，这里就不介绍。</p><p>举个栗子：这里用自己写的一个岩体分级的工具为例。逻辑非常简单：就是输入一堆参数，得到一个结果，通过结果对岩体进行分级，界面如下。</p><p><img src="/assets/images/2018/01/Qclassify-ui.png" alt=""></p><p>UI设计通过Qt Designer生成。</p><p>逻辑部分和UI部分分离，新建.py文件，创建一个类，继承QMainWindow和QtDesigner生成的UI类Ui_MainWindow。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class MainWindow(QMainWindow, Ui_MainWindow):</span><br><span class="line">    global QRD, Jn, Jr, Ja, Jw, SRF, res,rl</span><br><span class="line">    def __init__(self, parent = None):</span><br><span class="line">        QMainWindow.__init__(self,parent)</span><br><span class="line">        self.setupUi(self)</span><br></pre></td></tr></table></figure></p><p>继承父类Ui_MainWindow的setupUi方法，setupUi方法中通过控件的名字来自动连接槽：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QtCore.QMetaObject.connectSlotsByName(MainWindow)</span><br></pre></td></tr></table></figure></p><p>通过自定义槽函数来实现特定的功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def on_pushButton_clicked(self):</span><br><span class="line">    self.test()</span><br></pre></td></tr></table></figure></p><p>其中test()主要实现具体的逻辑功能，注意这里自定义槽函数的名称要和控件名称（pushButton）对应：on_pushButton\ _clicked。</p><p>通过实例ui的show()方法来显示程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    import sys</span><br><span class="line">    app = QtWidgets.QApplication(sys.argv)</span><br><span class="line">    ui = MainWindow()</span><br><span class="line">    ui.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure></p><p>这里对信号和槽做了粗浅的认识和学习，关于其他内容不再赘述，更多详细内容，可参照官方文档。</p><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p><a href="http://pyqt.sourceforge.net/Docs/PyQt5/index.html" target="_blank" rel="noopener">PyQt5 Reference Guide</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PyQt5中最核心的内容就是信号与槽。本文主要结合一个简单的实例对这部分内容进行详细的介绍。&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://likernel.github.io/tags/python/"/>
    
      <category term="PyQt5" scheme="http://likernel.github.io/tags/PyQt5/"/>
    
  </entry>
  
  <entry>
    <title>PyQt5+Pycharm环境搭建</title>
    <link href="http://likernel.github.io/2018/01/23/PyQt5-Pycharm%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://likernel.github.io/2018/01/23/PyQt5-Pycharm环境搭建/</id>
    <published>2018-01-23T00:35:50.000Z</published>
    <updated>2018-02-11T14:55:56.204Z</updated>
    
    <content type="html"><![CDATA[<p>最近要写一个岩石分级的工具，选择了PyQt5作为GUI开发的框架。本文介绍一下基本的环境的配置。<br><a id="more"></a></p><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><ul><li>Pycharm</li><li>Python 3.6(这里建议使用python3，在虚拟环境中配置)</li><li>PyQt5</li><li>SIP</li><li>Qt Designer<h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><h4 id="安装SIP"><a href="#安装SIP" class="headerlink" title="安装SIP"></a>安装SIP</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install SIP</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>sip是RiverBank（PyQt的开发商）开发的用于PyQt的Python/C++混合编程解决方案。由于Qt框架的复杂性，PyQt并没有使用Cython、SWIG的混合编程方案，而是自己单独做了一套框架。sip包括一个sip工具、SDK和Python Module。</p></blockquote><h4 id="安装PyQt5"><a href="#安装PyQt5" class="headerlink" title="安装PyQt5"></a>安装PyQt5</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install PyQt5</span><br></pre></td></tr></table></figure><h4 id="安装QtDesigner"><a href="#安装QtDesigner" class="headerlink" title="安装QtDesigner"></a>安装QtDesigner</h4><p>QtDesigner在pyqt5-tools这个包里面有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyqt5-tools</span><br></pre></td></tr></table></figure></p><h2 id="Pycharm配置"><a href="#Pycharm配置" class="headerlink" title="Pycharm配置"></a>Pycharm配置</h2><p>这里我们主要在Pycharm里面配置两个扩展工具。QtDesigner和PyUIC，前者是可视化UI编辑工具，后者是将.ui文件转成.py文件的工具。</p><h4 id="QtDesigner配置"><a href="#QtDesigner配置" class="headerlink" title="QtDesigner配置"></a>QtDesigner配置</h4><p>1.Ctrl+Alt+s调出设置-&gt;Tools-&gt;External Tools<br><img src="/assets/images/2018/01/Qt-designer-setting.png" alt=""></p><p>2.添加扩展工具Qt Designer<br><img src="/assets/images/2018/01/Qt-Designer-setting2.png" alt=""><br>Program填写designer.exe所在的路径，在pyqt5-tools包下面。<br>Working directory填写$ProjectFileDir$(项目目录，在Insert Macro…中可以选择)</p><h4 id="PyUIC配置"><a href="#PyUIC配置" class="headerlink" title="PyUIC配置"></a>PyUIC配置</h4><p>同Qt Designer的配置，具体的配置参数如下：<br><img src="/assets/images/2018/01/PyUIC-setting.png" alt=""><br>Program填写python.exe所在的路径（根据你的虚拟环境而定）。<br>Working directory填写$FileDir$(文件目录，在Insert Macro…中可以选择)<br>其中，Arguments的配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-m PyQt5.uic.pyuic  $FileName$ -o $FileNameWithoutExtension$.py</span><br></pre></td></tr></table></figure></p><p>这时候在External tools下可以看到这两个扩展工具。<br><img src="/assets/images/2018/01/external-tools.png" alt=""><br>点击QtDesigner就可以进入QtDesigner界面了，界面设计完成，可以通过PyUIC将设计的UI文件转化成python代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近要写一个岩石分级的工具，选择了PyQt5作为GUI开发的框架。本文介绍一下基本的环境的配置。&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://likernel.github.io/tags/python/"/>
    
      <category term="PyQt5" scheme="http://likernel.github.io/tags/PyQt5/"/>
    
  </entry>
  
  <entry>
    <title>scikit-neuralnetwork安装</title>
    <link href="http://likernel.github.io/2017/12/28/scikit-neuralnetwork%E5%AE%89%E8%A3%85/"/>
    <id>http://likernel.github.io/2017/12/28/scikit-neuralnetwork安装/</id>
    <published>2017-12-27T23:32:48.000Z</published>
    <updated>2018-02-11T14:54:13.499Z</updated>
    
    <content type="html"><![CDATA[<p>scikit-neuralnetwork是一个开源的深度学习的库，scikit-neuralnetwork的接口和设计规范都是参照scikit-learn，之前用过scikit-learn，对它比较熟悉，因此，准备用它作为深度学习的工具。本文主要介绍它的安装过程以及期间可能遇到的一些问题。<br><a id="more"></a></p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>Ubuntu 16.04</li><li>Python 3.5（virtualenv）</li></ul><p>注：选择Linux的原因，由于这些库的开发者在开发的时候用的都是Linux，出问题的话对应的好解决，Windows环境也可以部署，但是稍微麻烦一些。</p><p>Python的版本选择的是3.5，在沙箱环境virtualenv中，使用virtualenv的好处就是方便管理包，出现问题也可以直接删除这个环境，避免不必要的麻烦。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装scikit-neuralnetwork之前需要安装一些依赖（需要依赖的库）。</p><p>1.进入Python的沙箱环境，安装以下依赖。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pip install scikit-learn==0.17</span><br><span class="line">pip install scipy==0.17.0</span><br><span class="line">pip install Theano==0.8.1</span><br><span class="line">pip install git+https://github.com/Lasagne/Lasagne.git@0440814#egg=Lasagne==0.2-dev</span><br><span class="line">sudo pip install -U numpy</span><br><span class="line">pip install -e git+https://github.com/lisa-lab/pylearn2.git=Package</span><br><span class="line">pip install pandas</span><br><span class="line">pip install matplotlib</span><br></pre></td></tr></table></figure></p><p>2.安装scikit-neuralnetwork<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 将scikit-neuralnetwork源码从github上拷贝下来。</span><br><span class="line">git clone https://github.com/aigamedev/scikit-neuralnetwork.git</span><br><span class="line"># 进入scikit-neuralnetwork文件夹</span><br><span class="line">cd scikit-neuralnetwork</span><br><span class="line"># 安装</span><br><span class="line">python setup.py develop</span><br></pre></td></tr></table></figure></p><p>3.测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install nose</span><br><span class="line">nosetests -v sknn.tests</span><br></pre></td></tr></table></figure></p><p>正常情况下，到这一步不出现问题就安装好了。实际情况会遇到很多问题，下面总结一下常见的问题，和解决方案。</p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p>####各种依赖安装出错<br>最常见的是pylearn2。各种module不存在，cannot import等问题。</p><p>解决方案：在测试或者源码安装时，往往会出现上述情况，原因一般是版本的问题。由于网上的很多教程时间比较早，可能他们安装时不会出现这样的问题。因此，这里最好使用推荐的版本。下图是笔者安装时测试没问题的一些版本的包。</p><p><img src="/assets/images/2017/12/libs.png" alt=""></p><p>注：实在想用最新的版本，可以根据相应的问题修改源码（指的是pylearn2等第三方源码安装的），通常情况下是import出问题。</p><h4 id="测试时出现问题"><a href="#测试时出现问题" class="headerlink" title="测试时出现问题"></a>测试时出现问题</h4><p>1.ERROR：no modole named XXX<br>通常是上述包未安装完，可以根据提示安装完对应的包。记住安装完成后，可以通过 <code>pip list/freeze</code> check一下。</p><p>2.ImportError: libmkl_rt.so:cannot open shared object file: No such file or directory.</p><p>mkl是英特尔数学核心函数库，这个.so（shared object）文件就在进行上述测试时需要调用。但是找不到了。需要我们重新配置一番。<br>①进入<a href="https://software.intel.com/en-us/mkl" target="_blank" rel="noopener">官网</a>下载。</p><p>②找到libmkl_rt.so，一般在”/opt/intel/compilers_and_libraries_2018.1.163/linux/mkl/lib“下。“2018.1.163”一般是你下载的版本。可以看到，下面可以找到其所在位置。<br><img src="/content/images/2017/12/mkl.png" width="550px"></p><p>③让系统能找到，这里使用ldconfig方式。<br>在/etc/ld.so.conf.d下创建一个文件mylibs.conf（注意修改其权限为可写的）。编辑文件，将对应的路径添加进去。<br><img src="/assets/images/2017/12/mylib.conf.png" alt=""><br>注：上述路径可以不用添加那么多，这里是当时为了保险起见都加了。</p><p>④<code>sudo ldconfig</code> 重新加载对应的shared libraries。</p><p>⑤可以通过 <code>ldconfig -v</code>check一下安装成功没有。<br><img src="/assets/images/2017/12/ld.png" alt=""></p><p>这个时候再使用 <code>nosetests -v sknn.tests</code> 进行测试就没有问题了。</p><p>3.如遇到其他问题可随时留言。</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>1.首先来个多层神经网络的demo，examples下的plot_mlp.py<br>（官网和github上也是用的这个demo）。<br><img src="/assets/images/2017/12/Figure-1_001.png" alt=""><br>注：需要安装python3-tk，不然会出现上述“ERROR：no modole named XXX”错误。</p><p>2.再来个mnist数据集上的测试，随便找一个bench_mnist.py<br>下面是训练神经网络的过程。<br><img src="/assets/images/2017/12/bench.png" alt=""></p><p>注：这里由于数据量大，没有完全完全跑完，这里只是验证一下。<br>接下来，我们就可以愉快的进行deep learning的学习了。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>官网地址：<br><a href="https://scikit-neuralnetwork.readthedocs.io" target="_blank" rel="noopener">https://scikit-neuralnetwork.readthedocs.io</a></p><p>github地址：<a href="https://github.com/aigamedev/scikit-neuralnetwork" target="_blank" rel="noopener">https://github.com/aigamedev/scikit-neuralnetwork</a></p><p>以上便是scikit-neuralnetwork安装的整个过程，供自己学习记录，欢迎留言和转载（注明出处）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;scikit-neuralnetwork是一个开源的深度学习的库，scikit-neuralnetwork的接口和设计规范都是参照scikit-learn，之前用过scikit-learn，对它比较熟悉，因此，准备用它作为深度学习的工具。本文主要介绍它的安装过程以及期间可能遇到的一些问题。&lt;br&gt;
    
    </summary>
    
    
      <category term="深度学习" scheme="http://likernel.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>NN-神经网络</title>
    <link href="http://likernel.github.io/2017/12/23/NN-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>http://likernel.github.io/2017/12/23/NN-神经网络/</id>
    <published>2017-12-23T07:01:47.000Z</published>
    <updated>2018-02-11T15:15:02.197Z</updated>
    
    <content type="html"><![CDATA[<p>神经网络（Neural Network）是以人脑中的神经网络为启发的，历史上出现过很多不同的版本，其中最著名也是最常用的算法就是在1980提出的backpropagation(反向传播)，也可以称为BP神经网络，它被应用于多层向前神经网络（Multilayer Feed-Forward Neural Network）。<br><a id="more"></a></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>多层向前神经网络由3部分组成，输入层(input layer)，隐藏层(hidden layers)，输出层(output layers)。</p><p><img src="/assets/images/2017/12/BP-NN-2.jpg" alt=""></p><ul><li>每一层由单元（units）组成，我们也可称其为神经节点。</li><li>输入层（input layer）由训练集的实例特征向量传入。</li><li>经过连接点的权重传入下一层，一层的输出是下一层的输入。</li><li>隐藏层（hidden layer）的个数可以是任意的，输入层有一层，输出层有一层。</li><li>上面这幅图称为两层神经网络（输入层不算）。</li><li>作为多层向前神经网络，理论上，如果有足够多的隐藏层，和足够大的训练集，可以模拟出任何方程。</li></ul><h3 id="设计神经网络结构"><a href="#设计神经网络结构" class="headerlink" title="设计神经网络结构"></a>设计神经网络结构</h3><ol><li>使用神经网络训练数据之前，必须先设计神经网络的结构，也就是确定神经网络的层数以及每层的单元个数。</li><li>特征向量在被传入输入层时，通常要先标准化到0，1之间，目的是加速学习的过程。</li><li>离散型变量的可以被编码成：每一个输入单元对应一个特征值可能被赋的值。</li><li>没有特定的规则来说明最好设计多少个隐藏层，往往需要根据实验测试和误差，以及准确度来实验并改进。</li></ol><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>神经网络既可以做分类，也可以解决回归问题，<br>本文主要讨论分类问题。</p><ul><li>二分类：用一个输出单元表示（分别用0和1表示）。</li><li>多于两类：每一个类别用一个输出单元表示。</li></ul><p>所以，一般情况下，输出单元数量，往往等于类别数量。</p><h3 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h3><p>之前介绍的机器学习的一般框架主要是把一组数据分成训练集和测试集两部分。训练集来训练模型。测试集输入进去看结果是不是对的，根据正确率得到一个准确度。</p><p>机器学习中还有一种更常用和科学的方法，交叉验证方法(cross-validation)。下面来介绍一下这种方法。</p><p><img src="/assets/images/2017/12/cross-validation.jpg" alt=""></p><p>前面我们用机器学习的一般框架是把数据分成2份，一份测试集一份数据集。</p><p>交叉验证方法就是把数据分成更多份，比如像上图中分成3份，其中2份当做训练集，1份当做测试集。重复三次，就可以得到3个准确度，做一个均值就得到最终的准确度，这就是交叉验证。实际上可以分成任意的K份，所以这个方法也被称为K-fold cross validation。</p><h3 id="backpropagation算法"><a href="#backpropagation算法" class="headerlink" title="backpropagation算法"></a>backpropagation算法</h3><p>开篇的时候提到神经网络中最常用的算法就是backpropagation，下面是这种BP算法的主要思想:</p><ol><li>通过迭代性处理训练集中的实例。</li><li>对比经过神经网络后输入层预测值（predict value）和真实值（target value）。</li><li>反方向（output-&gt;hidden-&gt;input）来以最小化误差（error）来更新每个连接的权重（weight）。</li></ol><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>数据集、学习率（learning rate）和一个多层向前神经网络。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>一个训练好的神经网络。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>权重（weights）和偏向（bias，每个单元都有这样一个偏向）需要在开始时进行初始化，一般在-1到1或-0.5到0.5之间进行随机初始化。</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>对于一个训练实例X执行以下步骤：</p><ol><li>由输入层，向前传送，具体传递和计算过程见下图：</li></ol><p><img src="/assets/images/2017/12/bp.jpg" alt=""></p><p>$$I_j=\sum_{i}{} w_ij O_i+\theta_j$$</p><p>其中，\(O_j=\frac{1}{1+{e^{-I_j}}}\)</p><p>如上图所示n个单元，加权求和加上一个偏向后得到一个值，再代入上面的非线性转化方程，可以得到输出结果。</p><p>通过这样的方式就能够一步一步正向的计算出最后输出，接下来就是倒推回去修正优化神经网络。</p><p>2.根据误差（error）反向传送。</p><ul><li>输出层：\(E_{rr_j}=O_j(1-O_j)(T_j-O_j)\)</li><li>隐藏层：\(E_{rr_j}=O_j(1-O_j)\sum_{k}{} E_{rr_j} w_{jk}\)</li><li>权重更新：\(w_{ij}(new)=w_{ij}(old)+\Delta w_{ij}\)，其中，\(\Delta w_{ij}=(l)E_{rr_j}O_i\)，l为学习率（learning rate）。</li><li>偏向更新：\(\theta_j(new)=\theta_j(old)+\Delta \theta_j\)，其中，\(\Delta \theta_j=(l)E_{rr_j}O_i\)</li></ul><p>注：上述的更新实际上采用的是一种梯度爬行的方法。</p><p>3.终止条件。</p><ul><li>权重的更新低于某个阈值。</li><li>预测的错误率低于某个阈值。</li><li>达到预设的循环次数。</li></ul><p>实际上最核心的过程就是在不断的更新、优化权重和偏向。以上就是对神经网络的初步认识，为后面的深度学习打下基础，本文完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;神经网络（Neural Network）是以人脑中的神经网络为启发的，历史上出现过很多不同的版本，其中最著名也是最常用的算法就是在1980提出的backpropagation(反向传播)，也可以称为BP神经网络，它被应用于多层向前神经网络（Multilayer Feed-Forward Neural Network）。&lt;br&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://likernel.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="http://likernel.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>KNN-最邻近规则分类</title>
    <link href="http://likernel.github.io/2017/12/23/KNN-%E6%9C%80%E9%82%BB%E8%BF%91%E8%A7%84%E5%88%99%E5%88%86%E7%B1%BB/"/>
    <id>http://likernel.github.io/2017/12/23/KNN-最邻近规则分类/</id>
    <published>2017-12-23T06:59:48.000Z</published>
    <updated>2018-02-11T14:55:07.827Z</updated>
    
    <content type="html"><![CDATA[<p>KNN（K-Nearest Neighbor）是Cover&amp;Hart于1968年提出的一种分类算法，算法思想就是：<br>&gt;<br>1.为判断未知实例的类别，以所有已知类别的实例作为参考点；<br>2.选择参数K；<br>3.计算未知实例与所有已知实例的距离；<br>4.选择最近的K个已知实例；<br>5.根据投票法则，将未知实例归为K个最邻近样本中最多数的类别。</p><a id="more"></a><p>KNN就是这种“近朱者赤，近墨者黑”的思想，它由你的邻居来推断出你的类别。这里仅对以下一些细节进行补充说明。</p><h2 id="距离"><a href="#距离" class="headerlink" title="距离"></a>距离</h2><p>距离的衡量包括：欧式距离、余弦相似度、曼哈顿距离等。</p><p>欧式距离：<br>$$dist(X,Y)=\sqrt{\sum_{i=1}^{n} {(x_i-y_i)}^2}$$</p><p>余弦相似度（Cosine Similarity）：<br>$$sim(X,Y)=\cos\theta=\frac{\vec{x}\cdot \vec{y}}{||x||\cdot||y||}$$</p><p>曼哈顿距离：<br>$$dist(X,Y)=\sqrt{\sum_{i=1}^{n} {|x_i-y_i|}}$$<br>注：对于文本分类来说，使用余弦相似度来计算就比欧式距离更合适。</p><h2 id="关于K"><a href="#关于K" class="headerlink" title="关于K"></a>关于K</h2><p>k值通常是采用交叉检验来确定（以k=1为基准），一般低于训练样本数的平方根。</p><h2 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h2><p>1.优点：简单，易于理解，易于实现，无需估计参数，无需训练。适合对稀有事件进行分类，特别适合于多分类问题。<br>2.缺点：懒惰算法，对测试样本分类时的计算量大，内存开销大。可解释性较差，无法给出决策树那样的规则。</p><h2 id="改进版本"><a href="#改进版本" class="headerlink" title="改进版本"></a>改进版本</h2><p>对距离加权，距离越近，权重越大。例如：1/d。</p><p>本文完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;KNN（K-Nearest Neighbor）是Cover&amp;amp;Hart于1968年提出的一种分类算法，算法思想就是：&lt;br&gt;&amp;gt;&lt;br&gt;1.为判断未知实例的类别，以所有已知类别的实例作为参考点；&lt;br&gt;2.选择参数K；&lt;br&gt;3.计算未知实例与所有已知实例的距离；&lt;br&gt;4.选择最近的K个已知实例；&lt;br&gt;5.根据投票法则，将未知实例归为K个最邻近样本中最多数的类别。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://likernel.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>决策树</title>
    <link href="http://likernel.github.io/2017/12/23/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <id>http://likernel.github.io/2017/12/23/决策树/</id>
    <published>2017-12-23T06:55:35.000Z</published>
    <updated>2018-02-11T14:50:30.001Z</updated>
    
    <content type="html"><![CDATA[<p>决策树（decision tree）又称为判定树，是运用于分类的一种树结构，其中：<br>&gt;<br>1.每个内部节点代表对某一属性的一次测试。<br>2.每条边代表一个测试结果。<br>3.叶节点代表某个类或类的分布。</p><a id="more"></a><p>决策过程需要从根节点开始，测试集中的数据与决策树中的特征节点进行比较，并按照比较结果选择下一比较分支，直到叶子节点作为最终的决策结果。</p><p>实现决策树的核心就是选择属性判断节点，有很多标准，对应的就是不同的算法，最著名的有三个：ID3，C4.5和CART。在介绍之前，先了解一些预备知识。</p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h3><p>信息是个抽象概念。人们常说信息很多，或者信息较少，但很难说清楚信息到底有多少。1948年，香农提出了“信息熵”的概念，才解决了对信息的量化度量问题。</p><blockquote><p>热力学中的热熵是表示分子状态混乱程度的物理量。香农用信息熵的概念来描述信源的不确定度。</p></blockquote><p>一条信息的信息量大小和不确定性有直接的关系。如果信息的不确定性越大，熵的值也就越大。设D为用类别对训练元组进行的划分，则D的熵（entropy）表示为：</p><p>$$Info(D)=-\sum_{i=1}^{m} p_i log_{2}p_i$$</p><p>其中，D为所有事件集合，p为发生概率，m为特征总数。</p><blockquote><p>一般用比特（bit）来衡量信息的多少。当然，如果log不是以2为底，则使用的是其他的单位。</p></blockquote><h3 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h3><p>即信息获取量（information gain），原有信息熵与属性划分后信息熵的差值，具体计算法如下：</p><p>$$gain(A)=Info(D)-Info_A(D)$$</p><p>其中，第二项为将训练元组D按属性A进行划分：</p><p>$$Info_A(D)=\sum_{j=1}^{v} \frac{|D_j|}{|D|} Info(D_j)$$</p><h2 id="决策树归纳算法"><a href="#决策树归纳算法" class="headerlink" title="决策树归纳算法"></a>决策树归纳算法</h2><h3 id="ID3算法"><a href="#ID3算法" class="headerlink" title="ID3算法"></a>ID3算法</h3><p>ID3算法实际上就是在每次需要分裂时，计算每个属性的增益率，然后选择增益率最大的属性进行分裂。</p><h3 id="C4-5算法"><a href="#C4-5算法" class="headerlink" title="C4.5算法"></a>C4.5算法</h3><p> ID3算法存在一个问题，就是偏向于多值属性，例如，如果存在唯一标识属性ID，则ID3会选择它作为分裂属性，这样虽然使得划分充分纯净，但这种划分对分类几乎毫无用处。ID3的后继算法C4.5使用增益率（gain ratio）的信息增益扩充，试图克服这个偏倚。</p><p> C4.5算法首先定义了“分裂信息”，其定义可以表示成：</p><p>$$split\underline{} Info_A(D)=\sum_{j=1}^{v} \frac{|D_j|}{|D|} log_2(\frac{|D_j|}{|D|})$$</p><p>增益率被定义为：</p><p>$$gain\underline{} ratio(A)=\frac{gain}{split\underline{} Info(A)}$$</p><p> C4.5选择具有最大增益率的属性作为分裂属性。</p><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><p>在实际构造决策树时，通常要进行剪枝，主要是为了避免overfitting。剪枝有两种：</p><p>1.先剪枝：在构造过程中，当某个节点满足剪枝条件，则直接停止此分支的构造。<br>2.后剪枝：先构造完成完整的决策树，再通过某些条件遍历树进行剪枝。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>1.优点：直观、便于理解，小规模数据集有效。<br>2.缺点：处理连续变量时效果不好；类别较多时，错误增加较多；可规模性一般。</p><h3 id="一种特殊情况"><a href="#一种特殊情况" class="headerlink" title="一种特殊情况"></a>一种特殊情况</h3><p>在决策树构造过程中可能会出现这种情况：所有属性都作为分裂属性用完了，但有的子集还不是纯净集，即集合内的元素不属于同一类别。在这种情况下，一般采取“多数表决”，即使用此子集中出现次数最多的类别作为此节点类别，然后将此节点作为叶子节点。</p><p>关于决策树的概念先介绍这么多，具体实例和应用，会有后续文章讲解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;决策树（decision tree）又称为判定树，是运用于分类的一种树结构，其中：&lt;br&gt;&amp;gt;&lt;br&gt;1.每个内部节点代表对某一属性的一次测试。&lt;br&gt;2.每条边代表一个测试结果。&lt;br&gt;3.叶节点代表某个类或类的分布。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://likernel.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基本概念</title>
    <link href="http://likernel.github.io/2017/12/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://likernel.github.io/2017/12/23/机器学习基本概念/</id>
    <published>2017-12-23T04:46:00.000Z</published>
    <updated>2018-02-11T14:52:05.161Z</updated>
    
    <content type="html"><![CDATA[<p>由于论文需要，需要学习一下机器学习相关的知识，本文主要作为抛砖引玉，介绍机器学习的一些基础概念。<br><a id="more"></a></p><h2 id="概念学习"><a href="#概念学习" class="headerlink" title="概念学习"></a>概念学习</h2><blockquote><p>概念学习是指从有关某个布尔函数的输入输出训练样例中推断出该布尔函数，可以表示为：X-&gt;Y/C(x)。</p></blockquote><p>X：实例集，概念就是基于这个实例集的。<br>x：具体的实例。<br>C(x)：待学习的目标概念/函数。</p><p>###训练集和测试集<br>训练集：用来进行训练，产生模型/算法的数据集。</p><p>测试集：用来测试已经学习好的模型或算法。</p><h3 id="特征向量和标记"><a href="#特征向量和标记" class="headerlink" title="特征向量和标记"></a>特征向量和标记</h3><p>特征向量：属性的集合，通常用一个向量表示，附属于一个实例(x)。</p><p>标记：C(x)，实例类别的标记。</p><h3 id="正例和反例"><a href="#正例和反例" class="headerlink" title="正例和反例"></a>正例和反例</h3><p>正例：目标概念的成员。</p><p>反例：非目标概念的成员。</p><h2 id="分类和回归"><a href="#分类和回归" class="headerlink" title="分类和回归"></a>分类和回归</h2><p>分类和回归在机器学习中是很重要的两个领域，暂且先做如下简单的解释，不做深入的探讨。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>分类（classification）的目标标记（label）为类别性数据（离散型）。</p><h3 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h3><p>回归（regression）的目标标记（label）为连续性数值。</p><p>##有监督、无监督和半监督学习<br>机器学习主要分为三类：有监督学习、无监督学习和半监督学习。</p><h3 id="有监督学习"><a href="#有监督学习" class="headerlink" title="有监督学习"></a>有监督学习</h3><p>训练集<strong>有类别标记</strong>（即数据中包含分类的结果）。计算机进行学习之后，在丢给它新的数据，它能够算出结果。可以理解为“在类别标记的监督下进行学习”。</p><p>主要包括：分类和回归。</p><h3 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h3><p>训练集<strong>无类别标记</strong>。单纯凭借计算机强大的计算能力分析数据的特征，得出结果，通常是得到一些集合，集合内的数据在某些特征上相同或相似。可以理解为“没有在类别标记的监督下进行学习”。</p><p>主要包括：聚类。</p><h3 id="半监督学习"><a href="#半监督学习" class="headerlink" title="半监督学习"></a>半监督学习</h3><p>训练集<strong>一部分有类别标记，一部分没有类别标记</strong>。无类别标记的数据量往往远远大于有有标记的数据。<br>可以通过一些有类别标记的数据局部特征，和没类别标记数据的整体分布，得到可以接受甚至是非常好的分类结果。</p><p>主要包括：分类、回归、聚类和降维。</p><h2 id="机器学习一般步骤"><a href="#机器学习一般步骤" class="headerlink" title="机器学习一般步骤"></a>机器学习一般步骤</h2><p>这里不做详细的阐述，只列举一般的机器学习的步骤：</p><h3 id="1-问题定义"><a href="#1-问题定义" class="headerlink" title="1.问题定义"></a>1.问题定义</h3><p>通过观察类别确定究竟是分类还是回归问题。</p><h3 id="2-样本划分"><a href="#2-样本划分" class="headerlink" title="2.样本划分"></a>2.样本划分</h3><p>将数据划分为训练集和测试集。</p><h3 id="3-训练算法"><a href="#3-训练算法" class="headerlink" title="3.训练算法"></a>3.训练算法</h3><p>用训练集和训练集的特征向量训练算法。</p><h3 id="4-评估算法"><a href="#4-评估算法" class="headerlink" title="4.评估算法"></a>4.评估算法</h3><p>用学习来的算法用在测试集。其中，涉及调参和优化（调参还涉及到验证集）这里不做赘述。</p><p>本文主要起到一个抛砖引玉，为后面的学习，梳理一些基本的概念，本文完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于论文需要，需要学习一下机器学习相关的知识，本文主要作为抛砖引玉，介绍机器学习的一些基础概念。&lt;br&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://likernel.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode--Reverse Linked List</title>
    <link href="http://likernel.github.io/2017/08/23/Leetcode-Reverse-Linked-List/"/>
    <id>http://likernel.github.io/2017/08/23/Leetcode-Reverse-Linked-List/</id>
    <published>2017-08-23T00:06:53.000Z</published>
    <updated>2018-02-11T14:44:31.256Z</updated>
    
    <content type="html"><![CDATA[<p>翻转单链表。<br><a id="more"></a><br>链表的操作，关键就在指针。当然使用栈很容易实现，但是我们有更好的方法，就是借助三个指针。</p><p>pre：当前元素的前一个元素的指针<br>cur：当前元素的指针<br>nextp：当前元素的下一个元素的指针</p><p><strong>实现：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode(object):</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.next = None</span><br><span class="line"></span><br><span class="line">class Solution(object):</span><br><span class="line">    def reverseList(self, head):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        pre = None</span><br><span class="line">        cur = head</span><br><span class="line"></span><br><span class="line">        while cur != None:</span><br><span class="line">            nextp = cur.next</span><br><span class="line"></span><br><span class="line">            cur.next = pre   #翻转操作</span><br><span class="line"></span><br><span class="line">            pre = cur</span><br><span class="line">            cur = nextp      </span><br><span class="line">        return pre</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻转单链表。&lt;br&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://likernel.github.io/tags/leetcode/"/>
    
      <category term="算法" scheme="http://likernel.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="http://likernel.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Python读取文件</title>
    <link href="http://likernel.github.io/2017/08/21/Python%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6/"/>
    <id>http://likernel.github.io/2017/08/21/Python读取文件/</id>
    <published>2017-08-21T06:58:16.000Z</published>
    <updated>2018-02-11T15:38:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>python中读取文件常用的三种方法：read(),readline(),readlines()。在做笔试题的时候被这个东西卡了半天，遂总结一下。<br><a id="more"></a><br>假设a.txt的内容如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This is line1.</span><br><span class="line">This is line2.</span><br><span class="line">This is line3.</span><br></pre></td></tr></table></figure></p><p>#read()<br>语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read([size])</span><br></pre></td></tr></table></figure></p><p>从文件当前位置起读取size个字节，若无参数size，则表示读取至文件结束为止，它范围为字符串对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = open(&quot;a.txt&quot;)</span><br><span class="line">lines = f.read()</span><br><span class="line">print lines</span><br><span class="line">print(type(lines))</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">This is line1.</span><br><span class="line">This is line2.</span><br><span class="line">This is line3.</span><br><span class="line">&lt;type &apos;str&apos;&gt; #字符串类型</span><br></pre></td></tr></table></figure></p><h1 id="readline"><a href="#readline" class="headerlink" title="readline()"></a>readline()</h1><p>该方法每次读出一行内容，所以，读取时占用内存小，比较适合大文件，该方法返回一个字符串对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f = open(&quot;a.txt&quot;)</span><br><span class="line">line = f.readline()</span><br><span class="line">print(type(line))</span><br><span class="line">while line:</span><br><span class="line">    print line,</span><br><span class="line">    line = f.readline()</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;type &apos;str&apos;&gt;</span><br><span class="line">This is line1.</span><br><span class="line">This is line2.</span><br><span class="line">This is line3.</span><br></pre></td></tr></table></figure></p><p>#readlines()<br>读取整个文件所有行，保存在一个列表(list)变量中，每行作为一个元素，但读取大文件会比较占内存。<br>f = open(“a.txt”)<br>lines = f.readlines()<br>print(type(lines))<br>for line in lines:<br>    print line，<br>f.close()<br>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;type &apos;list&apos;&gt;</span><br><span class="line">This is line1.</span><br><span class="line">This is line2.</span><br><span class="line">This is line3.</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python中读取文件常用的三种方法：read(),readline(),readlines()。在做笔试题的时候被这个东西卡了半天，遂总结一下。&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://likernel.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python函数式编程</title>
    <link href="http://likernel.github.io/2017/08/17/Python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://likernel.github.io/2017/08/17/Python函数式编程/</id>
    <published>2017-08-17T03:15:34.000Z</published>
    <updated>2018-02-11T15:38:10.642Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍一下Python函数式编程的基本概念。<br><a id="more"></a></p><h1 id="命令式编程"><a href="#命令式编程" class="headerlink" title="命令式编程"></a>命令式编程</h1><p>首先从大家熟悉的命令式编程开始，我们先回顾下平时在写代码时主要的情景。</p><p>其实，不管我们的业务代码有多复杂，都离不开以下几类操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.函数定义：def</span><br><span class="line">2.条件控制：if, elif, else</span><br><span class="line">3.循环控制：for, break, continue, while</span><br></pre></td></tr></table></figure></p><p>当然，这只是部分操作类型，除此之外还应该有类和模块、异常处理等等。但考虑到是入门，我们就先只关注上面这三种最常见的操作。</p><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>对应地，函数式编程也有自己的关键字。在Python语言中，用于函数式编程的主要由3个基本函数和1个算子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.基本函数：map()、reduce()、filter()</span><br><span class="line">2.算子(operator)：lambda</span><br></pre></td></tr></table></figure></p><p>令人惊讶的是，仅仅采用这几个函数和算子就基本上可以实现任意Python程序。</p><p>当然，能实现是一回事儿，实际编码时是否这么写又是另外一回事儿。估计要真只采用这几个基本单元来写所有代码的话，不管是在表达上还是在阅读上应该都挺别扭的。不过，尝试采用这几个基本单元来替代上述的函数定义、条件控制、循环控制等操作，对理解函数式编程如何通过函数和递归表达流程控制应该会很有帮助。</p><h1 id="替换条件控制语句"><a href="#替换条件控制语句" class="headerlink" title="替换条件控制语句"></a>替换条件控制语句</h1><p>在对条件控制进行替换之前，我们先来回顾下Python中对布尔表达式求值时进行的“短路”处理。</p><p>什么叫“短路”处理？简单地讲，就是如下两点：</p><p>1.在f(x) and g(y)中，当f(x)为false时，不会再执行g(y)，直接返回false<br>2.在f(x) or g(y)中，当f(x)为true时，不会再执行g(y)，直接返回true<br>结论是显然易现的，就不再过多解释。</p><p>那么，对应到条件控制语句，我们不难理解，如下条件控制语句和表达式是等价的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># flow control statement</span><br><span class="line">if &lt;cond1&gt;:   func1()</span><br><span class="line">elif &lt;cond2&gt;: func2()</span><br><span class="line">else:         func3()</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Equivalent &quot;short circuit&quot; expression</span><br><span class="line">(&lt;cond1&gt; and func1()) or (&lt;cond2&gt; and func2()) or (func3())</span><br></pre></td></tr></table></figure><p>通过这个等价替换，我们就去除掉了if/elif/else关键词，将条件控制语句转换为一个表达式。而lambda算子返回的就是一个表达式。</p><p>基于这一点，我们就可以采用lambda创建如下函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pr = lambda s:s</span><br><span class="line">&gt;&gt;&gt; print_num = lambda x: (x==1 and pr(&quot;one&quot;))</span><br><span class="line">....                  or (x==2 and pr(&quot;two&quot;))</span><br><span class="line">....                  or (pr(&quot;other&quot;))</span><br><span class="line">&gt;&gt;&gt; print_num(1)</span><br><span class="line">&apos;one&apos;</span><br><span class="line">&gt;&gt;&gt; print_num(2)</span><br><span class="line">&apos;two&apos;</span><br><span class="line">&gt;&gt;&gt; print_num(3)</span><br><span class="line">&apos;other&apos;</span><br></pre></td></tr></table></figure></p><p>通过函数调用的结果可以看到，以上函数实现的功能与之前的条件控制语句实现的功能完全相同。</p><p>到这里，我们就实现了命令式条件控制语句向函数式语句的转换。并且这个转换的方法是通用的，所有条件控制语句都可以采用这种方式转换为函数式语句。</p><h1 id="替换循环控制语句"><a href="#替换循环控制语句" class="headerlink" title="替换循环控制语句"></a>替换循环控制语句</h1><p>接下来我们再看循环控制语句的转换。在Python中，循环控制是通过for和while这两种方式实现的。</p><p>##替换for循环</p><p>for循环语句的替换十分简单，采用map()函数就能轻松实现。这主要是因为for语句和map()原理相同，都是对可迭代对象里面的每一个元素进行操作，因此转换过程比较自然。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># statement-based for loop</span><br><span class="line">for e in lst:  func(e)</span><br><span class="line"></span><br><span class="line"># Equivalent map()-based loop</span><br><span class="line">map(func, lst)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; square = lambda x : x * x</span><br><span class="line">&gt;&gt;&gt; for x in [1,2,3,4,5]: square(x)</span><br><span class="line">...</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">9</span><br><span class="line">16</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; map(square, [1,2,3,4,5])</span><br><span class="line">[1, 4, 9, 16, 25]</span><br></pre></td></tr></table></figure><h2 id="替换while循环"><a href="#替换while循环" class="headerlink" title="替换while循环"></a>替换while循环</h2><p>while循环语句的替换相比而言就复杂了许多。</p><p>下面分别是while循环语句及其对应的函数式风格的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># statement-based while loop</span><br><span class="line">while &lt;condition&gt;:</span><br><span class="line">    &lt;pre-suite&gt;</span><br><span class="line">    if &lt;break_condition&gt;:</span><br><span class="line">        break</span><br><span class="line">    else:</span><br><span class="line">        &lt;suite&gt;</span><br><span class="line"></span><br><span class="line"># Equivalent FP-style recursive while loop</span><br><span class="line">def while_block():</span><br><span class="line">    &lt;pre-suite&gt;</span><br><span class="line">    if &lt;break_condition&gt;:</span><br><span class="line">        return 1</span><br><span class="line">    else:</span><br><span class="line">        &lt;suite&gt;</span><br><span class="line">    return 0</span><br><span class="line"></span><br><span class="line">while_FP = lambda: &lt;condition&gt; and (while_block() or while_FP())</span><br><span class="line">while_FP()</span><br></pre></td></tr></table></figure></p><p>这里的难点在于，函数式while_FP循环采用了递归的概念。当为true时，进入循环体，执行while_block()；若为true时，返回1，while_FP()调用结束；若为false时，返回0，会继续执行or右侧的while_FP()，从而实现递归调用；若始终为false，则会持续递归调用while_FP()，这就实现了while语句中同样的功能。</p><p>为了对函数式的while循环有更深刻的理解，可以再看下如下示例。这个例子是在网上找的，实现的是echo功能：输入任意非”quit”字符时，打印输入的字符；输入”quit”字符时，退出程序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  PythonFP python pyecho.py</span><br><span class="line">IMP -- 1</span><br><span class="line">1</span><br><span class="line">IMP -- 2</span><br><span class="line">2</span><br><span class="line">IMP -- abc</span><br><span class="line">abc</span><br><span class="line">IMP -- 1 + 1</span><br><span class="line">1 + 1</span><br><span class="line">IMP -- quit</span><br><span class="line">quit</span><br><span class="line">➜  PythonFP</span><br></pre></td></tr></table></figure></p><p>如下便是分别采用过程式和函数式语句实现的”echo”功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># imperative version of &quot;echo()&quot;</span><br><span class="line">def echo_IMP():</span><br><span class="line">    while 1:</span><br><span class="line">        x = raw_input(&quot;IMP -- &quot;)</span><br><span class="line">        print x</span><br><span class="line">        if x == &apos;quit&apos;:</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line">echo_IMP()</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def monadic_print(x):</span><br><span class="line">    print x</span><br><span class="line">    return x</span><br><span class="line"></span><br><span class="line"># FP version of &quot;echo()&quot;</span><br><span class="line">echo_FP = lambda: monadic_print(raw_input(&quot;FP -- &quot;))==&apos;quit&apos; or echo_FP()</span><br><span class="line">echo_FP()</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[^1]: (Python的函数式编程，从入门到放弃) <a href="http://python.jobbole.com/84927/" target="_blank" rel="noopener"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍一下Python函数式编程的基本概念。&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://likernel.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>filter()</title>
    <link href="http://likernel.github.io/2017/08/17/filter/"/>
    <id>http://likernel.github.io/2017/08/17/filter/</id>
    <published>2017-08-17T03:06:00.000Z</published>
    <updated>2018-02-09T07:36:06.164Z</updated>
    
    <content type="html"><![CDATA[<p>Python内建的filter()函数用于过滤序列。<br><a id="more"></a><br>和map()类似，filter()也接收一个函数和一个序列。和map()不同的时，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。</p><p>例如，在一个list中，删掉偶数，只保留奇数，可以这么写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def is_odd(n):</span><br><span class="line">    return n % 2 == 1</span><br><span class="line"></span><br><span class="line">filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15])</span><br><span class="line"># 结果: [1, 5, 9, 15]</span><br></pre></td></tr></table></figure></p><p>把一个序列中的空字符串删掉，可以这么写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def not_empty(s):</span><br><span class="line">    return s and s.strip()</span><br><span class="line"></span><br><span class="line">filter(not_empty, [&apos;A&apos;, &apos;&apos;, &apos;B&apos;, None, &apos;C&apos;, &apos;  &apos;])</span><br><span class="line"># 结果: [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]</span><br></pre></td></tr></table></figure></p><p>可见用filter()这个高阶函数，关键在于正确实现一个“筛选”函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python内建的filter()函数用于过滤序列。&lt;br&gt;
    
    </summary>
    
    
      <category term=" - python" scheme="http://likernel.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>map() and reduce()</title>
    <link href="http://likernel.github.io/2017/08/17/map-and-reduce/"/>
    <id>http://likernel.github.io/2017/08/17/map-and-reduce/</id>
    <published>2017-08-17T02:48:44.000Z</published>
    <updated>2018-02-11T15:40:05.208Z</updated>
    
    <content type="html"><![CDATA[<p>Python内建了map()和reduce()函数。<br><a id="more"></a></p><h1 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h1><p>map()函数的常见调用形式如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map(func, iterable)</span><br></pre></td></tr></table></figure></p><p>map()需要两个必填参数，第一个参数是一个函数名，第二个参数是一个可迭代的对象，如列表、元组等。</p><p>map()实现的功能很简单，就是将第二个参数（iterable）中的每一个元素分别传给第一个参数（func），依次执行函数得到结果，并将结果组成一个新的list对象后进行返回。返回结果永远都是一个list。</p><p>简单示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; double_func = lambda s : s * 2</span><br><span class="line">&gt;&gt;&gt; map(double_func, [1,2,3,4,5])</span><br><span class="line">[2, 4, 6, 8, 10]</span><br></pre></td></tr></table></figure></p><p>除了传入一个可迭代对象这种常见的模式外，map()还支持传入多个可迭代对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map(func, iterable1, iterable2)</span><br></pre></td></tr></table></figure></p><p>在传入多个可迭代对象的情况下，map()会依次从所有可迭代对象中依次取一个元素，组成一个元组列表，然后将元组依次传给func；若可迭代对象的长度不一致，则会以None进行补上。</p><p>通过以下示例应该就比较容易理解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; plus = lambda x,y : (x or 0) + (y or 0)</span><br><span class="line">&gt;&gt;&gt; map(plus, [1,2,3], [4,5,6])</span><br><span class="line">[5, 7, 9]</span><br><span class="line">&gt;&gt;&gt; map(plus, [1,2,3,4], [4,5,6])</span><br><span class="line">[5, 7, 9, 4]</span><br><span class="line">&gt;&gt;&gt; map(plus, [1,2,3], [4,5,6,7])</span><br><span class="line">[5, 7, 9, 7]</span><br></pre></td></tr></table></figure></p><p>在上面的例子中，之所以采用x or 0的形式，是为了防止None + int出现异常。</p><p>需要注意的是，可迭代对象的个数应该与func的参数个数一致，否则就会出现异常，因为传参个数与函数参数个数不一致了，这个应该比较好理解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; plus = lambda x,y : x + y</span><br><span class="line">&gt;&gt;&gt; map(plus, [1,2,3])</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: &lt;lambda&gt;() takes exactly 2 arguments (1 given)</span><br></pre></td></tr></table></figure></p><p>另外，map()还存在一种特殊情况，就是func为None。这个时候，map()仍然是从所有可迭代对象中依次取一个元素，组成一个元组列表，然后将这个元组列表作为结果进行返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; map(None, [1,2,3,4])</span><br><span class="line">[1, 2, 3, 4]</span><br><span class="line">&gt;&gt;&gt; map(None, [1,2,3,4], [5,6,7,8])</span><br><span class="line">[(1, 5), (2, 6), (3, 7), (4, 8)]</span><br><span class="line">&gt;&gt;&gt; map(None, [1,2,3,4], [5,6,7])</span><br><span class="line">[(1, 5), (2, 6), (3, 7), (4, None)]</span><br><span class="line">&gt;&gt;&gt; map(None, [1,2,3,4], [6,7,8,9], [11,12])</span><br><span class="line">[(1, 6, 11), (2, 7, 12), (3, 8, None), (4, 9, None)]</span><br></pre></td></tr></table></figure></p><h1 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h1><p>reduce()函数的调用形式如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(func, iterable[, initializer])</span><br></pre></td></tr></table></figure></p><p>reduce()函数的功能是对可迭代对象（iterable）中的元素从左到右进行累计运算，最终得到一个数值。第三个参数initializer是初始数值，可以空置，空置为None时就从可迭代对象（iterable）的第二个元素开始，并将第一个元素作为之前的结果。</p><p>看下reduce()的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def reduce(function, iterable, initializer=None):</span><br><span class="line">    it = iter(iterable)</span><br><span class="line">    if initializer is None:</span><br><span class="line">        try:</span><br><span class="line">            initializer = next(it)</span><br><span class="line">        except StopIteration:</span><br><span class="line">            raise TypeError(&apos;reduce() of empty sequence with no initial value&apos;)</span><br><span class="line">    accum_value = initializer</span><br><span class="line">    for x in it:</span><br><span class="line">        accum_value = function(accum_value, x)</span><br><span class="line">    return accum_value</span><br></pre></td></tr></table></figure></p><p>再加上如下示例，对reduce()的功能应该就能掌握了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; plus = lambda x, y : x + y</span><br><span class="line">&gt;&gt;&gt; reduce(plus, [1,2,3,4,5])</span><br><span class="line">15</span><br><span class="line">&gt;&gt;&gt; reduce(plus, [1,2,3,4,5], 10)</span><br><span class="line">25</span><br></pre></td></tr></table></figure></p><p>配合map()，我们就可以写出把str转换为int的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def fn(x, y):</span><br><span class="line">...     return x * 10 + y</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; def char2num(s):</span><br><span class="line">...     return &#123;&apos;0&apos;: 0, &apos;1&apos;: 1, &apos;2&apos;: 2, &apos;3&apos;: 3, &apos;4&apos;: 4, &apos;5&apos;: 5, &apos;6&apos;: 6, &apos;7&apos;: 7, &apos;8&apos;: 8, &apos;9&apos;: 9&#125;[s]</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; reduce(fn, map(char2num, &apos;13579&apos;))</span><br><span class="line">13579</span><br></pre></td></tr></table></figure></p><p>整理成一个str2int的函数就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def str2int(s):</span><br><span class="line">    def fn(x, y):</span><br><span class="line">        return x * 10 + y</span><br><span class="line">    def char2num(s):</span><br><span class="line">        return &#123;&apos;0&apos;: 0, &apos;1&apos;: 1, &apos;2&apos;: 2, &apos;3&apos;: 3, &apos;4&apos;: 4, &apos;5&apos;: 5, &apos;6&apos;: 6, &apos;7&apos;: 7, &apos;8&apos;: 8, &apos;9&apos;: 9&#125;[s]</span><br><span class="line">    return reduce(fn, map(char2num, s))</span><br></pre></td></tr></table></figure></p><p>还可以用lambda函数进一步简化成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def char2num(s):</span><br><span class="line">    return &#123;&apos;0&apos;: 0, &apos;1&apos;: 1, &apos;2&apos;: 2, &apos;3&apos;: 3, &apos;4&apos;: 4, &apos;5&apos;: 5, &apos;6&apos;: 6, &apos;7&apos;: 7, &apos;8&apos;: 8, &apos;9&apos;: 9&#125;[s]</span><br><span class="line"></span><br><span class="line">def str2int(s):</span><br><span class="line">    return reduce(lambda x,y: x*10+y, map(char2num, s))</span><br></pre></td></tr></table></figure></p><p>也就是说，假设Python没有提供int()函数，你完全可以自己写一个把字符串转化为整数的函数，而且只需要几行代码！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python内建了map()和reduce()函数。&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://likernel.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python协程</title>
    <link href="http://likernel.github.io/2017/08/17/Python%E5%8D%8F%E7%A8%8B/"/>
    <id>http://likernel.github.io/2017/08/17/Python协程/</id>
    <published>2017-08-17T02:22:10.000Z</published>
    <updated>2018-02-11T15:36:15.198Z</updated>
    
    <content type="html"><![CDATA[<p>协程，又称微线程，纤程。英文名Coroutine。<br><a id="more"></a><br>子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。</p><p>所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。</p><p>子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。</p><p>协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p><p>注意，在一个子程序中中断，去执行其他子程序，不是函数调用，有点类似CPU的中断。比如子程序A、B：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def A():</span><br><span class="line">    print &apos;1&apos;</span><br><span class="line">    print &apos;2&apos;</span><br><span class="line">    print &apos;3&apos;</span><br><span class="line"></span><br><span class="line">def B():</span><br><span class="line">    print &apos;x&apos;</span><br><span class="line">    print &apos;y&apos;</span><br><span class="line">    print &apos;z&apos;</span><br></pre></td></tr></table></figure></p><p>假设由协程执行，在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A，结果可能是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">x</span><br><span class="line">y</span><br><span class="line">3</span><br><span class="line">z</span><br></pre></td></tr></table></figure></p><p>但是在A中是没有调用B的，所以协程的调用比函数调用理解起来要难一些。</p><p>看起来A、B的执行有点像多线程，但协程的特点在于是一个线程执行，那和多线程比，协程有何优势？</p><p>最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p><p>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p><p>因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</p><p>Python对协程的支持还非常有限，用在generator中的yield可以一定程度上实现协程。虽然支持不完全，但已经可以发挥相当大的威力了。</p><p>来看例子：</p><p>传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。</p><p>如果改用协程，生产者生产消息后，直接通过yield跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def consumer():</span><br><span class="line">    r = &apos;&apos;</span><br><span class="line">    while True:</span><br><span class="line">        n = yield r</span><br><span class="line">        if not n:</span><br><span class="line">            return</span><br><span class="line">        print(&apos;[CONSUMER] Consuming %s...&apos; % n)</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        r = &apos;200 OK&apos;</span><br><span class="line"></span><br><span class="line">def produce(c):</span><br><span class="line">    c.next()</span><br><span class="line">    n = 0</span><br><span class="line">    while n &lt; 5:</span><br><span class="line">        n = n + 1</span><br><span class="line">        print(&apos;[PRODUCER] Producing %s...&apos; % n)</span><br><span class="line">        r = c.send(n)</span><br><span class="line">        print(&apos;[PRODUCER] Consumer return: %s&apos; % r)</span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    c = consumer()</span><br><span class="line">    produce(c)</span><br></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[PRODUCER] Producing 1...</span><br><span class="line">[CONSUMER] Consuming 1...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 2...</span><br><span class="line">[CONSUMER] Consuming 2...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 3...</span><br><span class="line">[CONSUMER] Consuming 3...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 4...</span><br><span class="line">[CONSUMER] Consuming 4...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 5...</span><br><span class="line">[CONSUMER] Consuming 5...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br></pre></td></tr></table></figure></p><p>注意到consumer函数是一个generator（生成器），把一个consumer传入produce后：<br>首先调用c.next()启动生成器；然后，一旦生产了东西，通过c.send(n)切换到consumer执行；consumer通过yield拿到消息，处理，又通过yield把结果传回；produce拿到consumer处理的结果，继续生产下一条消息；produce决定不生产了，通过c.close()关闭consumer，整个过程结束。</p><p>整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务。</p><p>最后套用Donald Knuth的一句话总结协程的特点：</p><blockquote><p>“子程序就是协程的一种特例。”</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;协程，又称微线程，纤程。英文名Coroutine。&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://likernel.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python切片</title>
    <link href="http://likernel.github.io/2017/08/17/Python%E5%88%87%E7%89%87/"/>
    <id>http://likernel.github.io/2017/08/17/Python切片/</id>
    <published>2017-08-17T01:13:59.000Z</published>
    <updated>2018-02-11T15:37:08.790Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍一下Python切片。<br><a id="more"></a><br>取一个list或tuple的部分元素是非常常见的操作。Python提供了切片（Slice）操作符，能大大简化这种操作。例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;, &apos;Bob&apos;, &apos;Jack&apos;]</span><br></pre></td></tr></table></figure></p><p>取前3个元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[0:3]</span><br><span class="line">[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;]</span><br></pre></td></tr></table></figure></p><p>L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。</p><p>如果第一个索引是0，还可以省略：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[:3]</span><br><span class="line">[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;]</span><br></pre></td></tr></table></figure></p><p>也可以从索引1开始，取出2个元素出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[1:3]</span><br><span class="line">[&apos;Sarah&apos;, &apos;Tracy&apos;]</span><br></pre></td></tr></table></figure></p><p>类似的，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[-2:]</span><br><span class="line">[&apos;Bob&apos;, &apos;Jack&apos;]</span><br><span class="line">&gt;&gt;&gt; L[-2:-1]</span><br><span class="line">[&apos;Bob&apos;]</span><br></pre></td></tr></table></figure></p><p>记住倒数第一个元素的索引是-1。</p><p>切片操作十分有用。我们先创建一个0-99的数列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = range(100)</span><br><span class="line">&gt;&gt;&gt; L</span><br><span class="line">[0, 1, 2, 3, ..., 99]</span><br></pre></td></tr></table></figure></p><p>可以通过切片轻松取出某一段数列。比如前10个数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[:10]</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure></p><p>后10个数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[-10:]</span><br><span class="line">[90, 91, 92, 93, 94, 95, 96, 97, 98, 99]</span><br></pre></td></tr></table></figure></p><p>前11-20个数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[10:20]</span><br><span class="line">[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</span><br></pre></td></tr></table></figure></p><p>前10个数，每两个取一个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[:10:2]</span><br><span class="line">[0, 2, 4, 6, 8]</span><br></pre></td></tr></table></figure></p><p>所有数，每5个取一个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[::5]</span><br><span class="line">[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]</span><br></pre></td></tr></table></figure></p><p>甚至什么都不写，只写[:]就可以原样复制一个list：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[:]</span><br><span class="line">[0, 1, 2, 3, ..., 99]</span><br></pre></td></tr></table></figure></p><p>tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; (0, 1, 2, 3, 4, 5)[:3]</span><br><span class="line">(0, 1, 2)</span><br></pre></td></tr></table></figure></p><p>字符串’xxx’或Unicode字符串u’xxx’也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;ABCDEFG&apos;[:3]</span><br><span class="line">&apos;ABC&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;ABCDEFG&apos;[::2]</span><br><span class="line">&apos;ACEG&apos;</span><br></pre></td></tr></table></figure></p><p>在很多编程语言中，针对字符串提供了很多各种截取函数，其实目的就是对字符串切片。Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>有了切片操作，很多地方循环就不再需要了。Python的切片非常灵活，一行代码就可以实现很多行循环才能完成的操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍一下Python切片。&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://likernel.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python线程</title>
    <link href="http://likernel.github.io/2017/08/17/Python%E7%BA%BF%E7%A8%8B/"/>
    <id>http://likernel.github.io/2017/08/17/Python线程/</id>
    <published>2017-08-16T21:32:13.000Z</published>
    <updated>2018-02-11T15:36:25.283Z</updated>
    
    <content type="html"><![CDATA[<p>多任务可以由多进程完成，也可以由一个进程内的多线程完成。我们前面提到了进程是由若干线程组成的，一个进程至少有一个线程。由于线程是操作系统直接支持的执行单元，因此，高级语言通常都内置多线程的支持，Python也不例外，并且，Python的线程是真正的Posix Thread，而不是模拟出来的线程。<br><a id="more"></a></p><p>Python的标准库提供了两个模块：thread和threading，thread是低级模块，threading是高级模块，对thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。</p><h1 id="threading"><a href="#threading" class="headerlink" title="threading"></a>threading</h1><p>启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import time, threading</span><br><span class="line"></span><br><span class="line"># 新线程执行的代码:</span><br><span class="line">def loop():</span><br><span class="line">    print &apos;thread %s is running...&apos; % threading.current_thread().name</span><br><span class="line">    n = 0</span><br><span class="line">    while n &lt; 5:</span><br><span class="line">        n = n + 1</span><br><span class="line">        print &apos;thread %s &gt;&gt;&gt; %s&apos; % (threading.current_thread().name, n)</span><br><span class="line">        time.sleep(1)</span><br><span class="line">    print &apos;thread %s ended.&apos; % threading.current_thread().name</span><br><span class="line"></span><br><span class="line">print &apos;thread %s is running...&apos; % threading.current_thread().name</span><br><span class="line">t = threading.Thread(target=loop, name=&apos;LoopThread&apos;)</span><br><span class="line">t.start()</span><br><span class="line">t.join()</span><br><span class="line">print &apos;thread %s ended.&apos; % threading.current_thread().name</span><br></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">thread MainThread is running...</span><br><span class="line">thread LoopThread is running...</span><br><span class="line">thread LoopThread &gt;&gt;&gt; 1</span><br><span class="line">thread LoopThread &gt;&gt;&gt; 2</span><br><span class="line">thread LoopThread &gt;&gt;&gt; 3</span><br><span class="line">thread LoopThread &gt;&gt;&gt; 4</span><br><span class="line">thread LoopThread &gt;&gt;&gt; 5</span><br><span class="line">thread LoopThread ended.</span><br><span class="line">thread MainThread ended.</span><br></pre></td></tr></table></figure></p><p>由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的threading模块有个current_thread()函数，它永远返回当前线程的实例。</p><p>主线程实例的名字叫MainThread，子线程的名字在创建时指定，我们用LoopThread命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为Thread-1，Thread-2……</p><h1 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h1><p>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。</p><p>来看看多个线程同时操作一个变量怎么把内容给改乱了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import time, threading</span><br><span class="line"></span><br><span class="line"># 假定这是你的银行存款:</span><br><span class="line">balance = 0</span><br><span class="line"></span><br><span class="line">def change_it(n):</span><br><span class="line">    # 先存后取，结果应该为0:</span><br><span class="line">    global balance</span><br><span class="line">    balance = balance + n</span><br><span class="line">    balance = balance - n</span><br><span class="line"></span><br><span class="line">def run_thread(n):</span><br><span class="line">    for i in range(100000):</span><br><span class="line">        change_it(n)</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=run_thread, args=(5,))</span><br><span class="line">t2 = threading.Thread(target=run_thread, args=(8,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line">print balance</span><br></pre></td></tr></table></figure></p><p>我们定义了一个共享变量balance，初始值为0，并且启动两个线程，先存后取，理论上结果应该为0，但是，由于线程的调度是由操作系统决定的，当t1、t2交替执行时，只要循环次数足够多，balance的结果就不一定是0了。</p><p>原因是因为高级语言的一条语句在CPU执行时是若干条语句，即使一个简单的计算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">balance = balance + n</span><br></pre></td></tr></table></figure></p><p>也分两步：</p><p>1.计算balance + n，存入临时变量中；<br>2.将临时变量的值赋给balance。</p><p>也就是可以看成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = balance + n</span><br><span class="line">balance = x</span><br></pre></td></tr></table></figure></p><p>由于x是局部变量，两个线程各自都有自己的x，当代码正常执行时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">初始值 balance = 0</span><br><span class="line"></span><br><span class="line">t1: x1 = balance + 5 # x1 = 0 + 5 = 5</span><br><span class="line">t1: balance = x1     # balance = 5</span><br><span class="line">t1: x1 = balance - 5 # x1 = 5 - 5 = 0</span><br><span class="line">t1: balance = x1     # balance = 0</span><br><span class="line"></span><br><span class="line">t2: x2 = balance + 8 # x2 = 0 + 8 = 8</span><br><span class="line">t2: balance = x2     # balance = 8</span><br><span class="line">t2: x2 = balance - 8 # x2 = 8 - 8 = 0</span><br><span class="line">t2: balance = x2     # balance = 0</span><br><span class="line"></span><br><span class="line">结果 balance = 0</span><br></pre></td></tr></table></figure></p><p>但是t1和t2是交替运行的，如果操作系统以下面的顺序执行t1、t2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">初始值 balance = 0</span><br><span class="line"></span><br><span class="line">t1: x1 = balance + 5  # x1 = 0 + 5 = 5</span><br><span class="line"></span><br><span class="line">t2: x2 = balance + 8  # x2 = 0 + 8 = 8</span><br><span class="line">t2: balance = x2      # balance = 8</span><br><span class="line"></span><br><span class="line">t1: balance = x1      # balance = 5</span><br><span class="line">t1: x1 = balance - 5  # x1 = 5 - 5 = 0</span><br><span class="line">t1: balance = x1      # balance = 0</span><br><span class="line"></span><br><span class="line">t2: x2 = balance - 5  # x2 = 0 - 5 = -5</span><br><span class="line">t2: balance = x2      # balance = -5</span><br><span class="line"></span><br><span class="line">结果 balance = -5</span><br></pre></td></tr></table></figure></p><p>究其原因，是因为修改balance需要多条语句，而执行这几条语句时，线程可能中断，从而导致多个线程把同一个对象的内容改乱了。</p><p>两个线程同时一存一取，就可能导致余额不对，你肯定不希望你的银行存款莫名其妙地变成了负数，所以，我们必须确保一个线程在修改balance的时候，别的线程一定不能改。</p><p>如果我们要确保balance计算正确，就要给change_it()上一把锁，当某个线程开始执行change_it()时，我们说，该线程因为获得了锁，因此其他线程不能同时执行change_it()，只能等待，直到锁被释放后，获得该锁以后才能改。由于锁只有一个，无论多少线程，同一时刻最多只有一个线程持有该锁，所以，不会造成修改的冲突。创建一个锁就是通过threading.Lock()来实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">balance = 0</span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">def run_thread(n):</span><br><span class="line">    for i in range(100000):</span><br><span class="line">        # 先要获取锁:</span><br><span class="line">        lock.acquire()</span><br><span class="line">        try:</span><br><span class="line">            # 放心地改吧:</span><br><span class="line">            change_it(n)</span><br><span class="line">        finally:</span><br><span class="line">            # 改完了一定要释放锁:</span><br><span class="line">            lock.release()</span><br></pre></td></tr></table></figure></p><p>当多个线程同时执行lock.acquire()时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。</p><p>获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用try…finally来确保锁一定会被释放。</p><p>锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也很多，首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。</p><h1 id="多核CPU"><a href="#多核CPU" class="headerlink" title="多核CPU"></a>多核CPU</h1><p>如果写一个死循环的话，我们可以监控到一个死循环线程会100%占用一个CPU。<br>如果有两个死循环线程，在多核CPU中，可以监控到会占用200%的CPU，也就是占用两个CPU核心。正常情况下要想把N核CPU的核心全部跑满，就必须启动N个死循环线程。</p><p>试试用Python写个死循环：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import threading, multiprocessing</span><br><span class="line"></span><br><span class="line">def loop():</span><br><span class="line">    x = 0</span><br><span class="line">    while True:</span><br><span class="line">        x = x ^ 1</span><br><span class="line"></span><br><span class="line">for i in range(multiprocessing.cpu_count()):</span><br><span class="line">    t = threading.Thread(target=loop)</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure></p><p>启动与CPU核心数量相同的N个线程，在4核CPU上可以监控到CPU占用率仅有160%，也就是使用不到两核。</p><p>即使启动100个线程，使用率也就170%左右，仍然不到两核。</p><p>但是用C、C++或Java来改写相同的死循环，直接可以把全部核心跑满，4核就跑到400%，8核就跑到800%，为什么Python不行呢？</p><p>因为Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</p><p>GIL是Python解释器设计的历史遗留问题，通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。</p><p>所以，在Python中，可以使用多线程，但不要指望能有效利用多核。如果一定要通过多线程利用多核，那只能通过C扩展来实现，不过这样就失去了Python简单易用的特点。</p><p>不过，也不用过于担心，Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。</p><p>#小结</p><p>多线程编程，模型复杂，容易发生冲突，必须用锁加以隔离，同时，又要小心死锁的发生。</p><p>Python解释器由于设计时有GIL全局锁，导致了多线程无法利用多核。多线程的并发在Python中就是一个美丽的梦。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多任务可以由多进程完成，也可以由一个进程内的多线程完成。我们前面提到了进程是由若干线程组成的，一个进程至少有一个线程。由于线程是操作系统直接支持的执行单元，因此，高级语言通常都内置多线程的支持，Python也不例外，并且，Python的线程是真正的Posix Thread，而不是模拟出来的线程。&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://likernel.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python进程</title>
    <link href="http://likernel.github.io/2017/08/17/Python%E8%BF%9B%E7%A8%8B/"/>
    <id>http://likernel.github.io/2017/08/17/Python进程/</id>
    <published>2017-08-16T21:31:54.000Z</published>
    <updated>2018-02-11T15:37:49.845Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍和Python进程相关的内容。<br><a id="more"></a></p><h1 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h1><p>Unix/Linux操作系统提供了一个fork()系统调用，用来把当前进程（父进程）复制了一份（子进程）。</p><p>在Python的os模块封装了常见的系统调用，其中就包括fork，可以在Python程序中轻松创建子进程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">pid = os.fork()</span><br><span class="line"></span><br><span class="line">if pid == 0:</span><br><span class="line">    print(&apos;哈哈1&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;哈哈2&apos;)</span><br></pre></td></tr></table></figure></p><p>1.程序执行到os.fork()时，操作系统会创建一个新的进程（子进程），然后复制父进程的所有信息到子进程中。<br>2.然后父进程和子进程都会从fork()函数中得到一个返回值，在子进程中这个值一定是0，而父进程中是子进程的 id号。</p><p>这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">rpid = os.fork()</span><br><span class="line">if rpid&lt;0:</span><br><span class="line">    print(&quot;fork调用失败。&quot;)</span><br><span class="line">elif rpid == 0:</span><br><span class="line">    print(&quot;我是子进程（%s），我的父进程是（%s）&quot;%(os.getpid(),os.getppid()))</span><br><span class="line">    x+=1</span><br><span class="line">else:</span><br><span class="line">    print(&quot;我是父进程（%s），我的子进程是（%s）&quot;%(os.getpid(),rpid))</span><br><span class="line"></span><br><span class="line">print(&quot;父子进程都可以执行这里的代码&quot;)</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我是父进程（19360），我的子进程是（19361）</span><br><span class="line">父子进程都可以执行这里的代码</span><br><span class="line">我是子进程（19361），我的父进程是（19360）</span><br><span class="line">父子进程都可以执行这里的代码</span><br></pre></td></tr></table></figure></p><p>由于Windows没有fork调用，上面的代码在Windows上无法运行，这样显然不适合这种跨平台的开发，因此，Python提供一个multiprocessing模块来支持跨平台的多进程。</p><h1 id="multiprocessing"><a href="#multiprocessing" class="headerlink" title="multiprocessing"></a>multiprocessing</h1><p>python中的多线程其实并不是真正的多线程，如果想要充分地使用多核CPU的资源，在python中大部分情况需要使用多进程。Python提供了非常好用的多进程包multiprocessing，只需要定义一个函数，Python会完成其他所有事情。借助这个包，可以轻松完成从单进程到并发执行的转换。multiprocessing支持子进程、通信和共享数据、执行不同形式的同步，提供了Process、Queue、Pipe、Lock等组件。</p><h2 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h2><p>Process语法结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Process([group [, target [, name [, args [, kwargs]]]]])</span><br></pre></td></tr></table></figure></p><p>1.<code>target</code>：表示这个进程实例所调用对象；<br>2.<code>args</code>：表示调用对象的位置参数元组；<br>3.<code>kwargs</code>：表示调用对象的关键字参数字典；<br>4.<code>name</code>：为当前进程实例的别名；<br>5.<code>group</code>：大多数情况下用不到；</p><h3 id="Process类常用方法："><a href="#Process类常用方法：" class="headerlink" title="Process类常用方法："></a>Process类常用方法：</h3><p>1.<code>is_alive()</code>：判断进程实例是否还在执行；<br>2.<code>join([timeout])</code>：是否等待进程实例执行结束，或等待多少秒；<br>3.<code>start()</code>：启动进程实例（创建子进程）；<br>4.<code>run()</code>：如果没有给定target参数，对这个对象调用start()方法时，就将执行对象中的run()方法；<br>5.<code>terminate()</code>：不管任务是否完成，立即终止；</p><h3 id="Process类常用属性："><a href="#Process类常用属性：" class="headerlink" title="Process类常用属性："></a>Process类常用属性：</h3><p>1.<code>name</code>：当前进程实例别名，默认为Process-N，N为从1开始递增的整数；<br>2.<code>pid</code>：当前进程实例的PID值；</p><h3 id="创建函数并将其作为单个进程"><a href="#创建函数并将其作为单个进程" class="headerlink" title="创建函数并将其作为单个进程"></a>创建函数并将其作为单个进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import os</span><br><span class="line">from time import sleep</span><br><span class="line"></span><br><span class="line"># 子进程要执行的代码</span><br><span class="line">def run_proc(name, age, **kwargs):</span><br><span class="line">    for i in range(10):</span><br><span class="line">        print(&apos;子进程运行中，name= %s,age=%d ,pid=%d...&apos; % (name, age,os.getpid()))</span><br><span class="line">        print(kwargs)</span><br><span class="line">        sleep(0.5)</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    print(&apos;父进程 %d.&apos; % os.getpid())</span><br><span class="line">    p = Process(target=run_proc, args=(&apos;test&apos;,18), kwargs=&#123;&quot;m&quot;:20&#125;)</span><br><span class="line">    print(&apos;子进程将要执行&apos;)</span><br><span class="line">    p.start()</span><br><span class="line">    sleep(1)</span><br><span class="line">    p.terminate()</span><br><span class="line">    p.join()</span><br><span class="line">    print(&apos;子进程已结束&apos;)</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">父进程 21378.</span><br><span class="line">子进程将要执行</span><br><span class="line">子进程运行中，name= test,age=18 ,pid=21379...</span><br><span class="line">&#123;&apos;m&apos;: 20&#125;</span><br><span class="line">子进程运行中，name= test,age=18 ,pid=21379...</span><br><span class="line">&#123;&apos;m&apos;: 20&#125;</span><br><span class="line">子进程已结束</span><br></pre></td></tr></table></figure></p><h3 id="创建函数并将其作为多个进程"><a href="#创建函数并将其作为多个进程" class="headerlink" title="创建函数并将其作为多个进程"></a>创建函数并将其作为多个进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line">from multiprocessing import Process</span><br><span class="line">import time</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">#两个子进程将会调用的两个方法</span><br><span class="line">def  worker_1(interval):</span><br><span class="line">    print(&quot;worker_1,父进程(%s),当前进程(%s)&quot;%(os.getppid(),os.getpid()))</span><br><span class="line">    t_start = time.time()</span><br><span class="line">    time.sleep(interval) #程序将会被挂起interval秒</span><br><span class="line">    t_end = time.time()</span><br><span class="line">    print(&quot;worker_1,执行时间为&apos;%0.2f&apos;秒&quot;%(t_end - t_start))</span><br><span class="line"></span><br><span class="line">def  worker_2(interval):</span><br><span class="line">    print(&quot;worker_2,父进程(%s),当前进程(%s)&quot;%(os.getppid(),os.getpid()))</span><br><span class="line">    t_start = time.time()</span><br><span class="line">    time.sleep(interval)</span><br><span class="line">    t_end = time.time()</span><br><span class="line">    print(&quot;worker_2,执行时间为&apos;%0.2f&apos;秒&quot;%(t_end - t_start))</span><br><span class="line"></span><br><span class="line">#输出当前程序的ID</span><br><span class="line">print(&quot;进程ID：%s&quot;%os.getpid())</span><br><span class="line"></span><br><span class="line">#创建两个进程对象，target指向这个进程对象要执行的对象名称，</span><br><span class="line">#args后面的元组中，是要传递给worker_1方法的参数，</span><br><span class="line">#因为worker_1方法就一个interval参数，这里传递一个整数2给它，</span><br><span class="line">#如果不指定name参数，默认的进程对象名称为Process-N，N为一个递增的整数</span><br><span class="line">p1=Process(target=worker_1,args=(2,))</span><br><span class="line">p2=Process(target=worker_2,name=&quot;dongGe&quot;,args=(1,))</span><br><span class="line"></span><br><span class="line">#使用&quot;进程对象名称.start()&quot;来创建并执行一个子进程，</span><br><span class="line">#这两个进程对象在start后，就会分别去执行worker_1和worker_2方法中的内容</span><br><span class="line">p1.start()</span><br><span class="line">p2.start()</span><br><span class="line"></span><br><span class="line">#同时父进程仍然往下执行，如果p2进程还在执行，将会返回True</span><br><span class="line">print(&quot;p2.is_alive=%s&quot;%p2.is_alive())</span><br><span class="line"></span><br><span class="line">#输出p1和p2进程的别名和pid</span><br><span class="line">print(&quot;p1.name=%s&quot;%p1.name)</span><br><span class="line">print(&quot;p1.pid=%s&quot;%p1.pid)</span><br><span class="line">print(&quot;p2.name=%s&quot;%p2.name)</span><br><span class="line">print(&quot;p2.pid=%s&quot;%p2.pid)</span><br><span class="line"></span><br><span class="line">#join括号中不携带参数，表示父进程在这个位置要等待p1进程执行完成后，</span><br><span class="line">#再继续执行下面的语句，一般用于进程间的数据同步，如果不写这一句，</span><br><span class="line">#下面的is_alive判断将会是True，在shell（cmd）里面调用这个程序时</span><br><span class="line">#可以完整的看到这个过程，大家可以尝试着将下面的这条语句改成p1.join(1)，</span><br><span class="line">#因为p2需要2秒以上才可能执行完成，父进程等待1秒很可能不能让p1完全执行完成，</span><br><span class="line">#所以下面的print会输出True，即p1仍然在执行</span><br><span class="line">p1.join()</span><br><span class="line">print(&quot;p1.is_alive=%s&quot;%p1.is_alive())</span><br></pre></td></tr></table></figure><p>结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">进程ID：19866</span><br><span class="line">p2.is_alive=True</span><br><span class="line">p1.name=Process-1</span><br><span class="line">p1.pid=19867</span><br><span class="line">p2.name=dongGe</span><br><span class="line">p2.pid=19868</span><br><span class="line">worker_1,父进程(19866),当前进程(19867)</span><br><span class="line">worker_2,父进程(19866),当前进程(19868)</span><br><span class="line">worker_2,执行时间为&apos;1.00&apos;秒</span><br><span class="line">worker_1,执行时间为&apos;2.00&apos;秒</span><br><span class="line">p1.is_alive=False</span><br></pre></td></tr></table></figure></p><h3 id="将进程定义为类"><a href="#将进程定义为类" class="headerlink" title="将进程定义为类"></a>将进程定义为类</h3><p>创建新的进程还能够使用类的方式，可以自定义一个类，继承Process类，每次实例化这个类的时候，就等同于实例化一个进程对象，请看下面的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import time</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">#继承Process类</span><br><span class="line">class Process_Class(Process):</span><br><span class="line">    #因为Process类本身也有__init__方法，这个子类相当于重写了这个方法，</span><br><span class="line">    #但这样就会带来一个问题，我们并没有完全的初始化一个Process类，所以就不能使用从这个类继承的一些方法和属性，</span><br><span class="line">    #最好的方法就是将继承类本身传递给Process.__init__方法，完成这些初始化操作</span><br><span class="line">    def __init__(self,interval):</span><br><span class="line">        Process.__init__(self)</span><br><span class="line">        self.interval = interval</span><br><span class="line"></span><br><span class="line">    #重写了Process类的run()方法</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&quot;子进程(%s) 开始执行，父进程为（%s）&quot;%(os.getpid(),os.getppid()))</span><br><span class="line">        t_start = time.time()</span><br><span class="line">        time.sleep(self.interval)</span><br><span class="line">        t_stop = time.time()</span><br><span class="line">        print(&quot;(%s)执行结束，耗时%0.2f秒&quot;%(os.getpid(),t_stop-t_start))</span><br><span class="line"></span><br><span class="line">if __name__==&quot;__main__&quot;:</span><br><span class="line">    t_start = time.time()</span><br><span class="line">    print(&quot;当前程序进程(%s)&quot;%os.getpid())        </span><br><span class="line">    p1 = Process_Class(2)</span><br><span class="line">    #对一个不包含target属性的Process类执行start()方法，就会运行这个类中的run()方法，所以这里会执行p1.run()</span><br><span class="line">    p1.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    t_stop = time.time()</span><br><span class="line">    print(&quot;(%s)执行结束，耗时%0.2f&quot;%(os.getpid(),t_stop-t_start))</span><br></pre></td></tr></table></figure></p><h2 id="进程池Pool"><a href="#进程池Pool" class="headerlink" title="进程池Pool"></a>进程池Pool</h2><p>当需要创建的子进程数量不多时，可以直接利用multiprocessing中的Process动态成生多个进程，但如果是上百甚至上千个目标，手动的去创建进程的工作量巨大，此时就可以用到multiprocessing模块提供的Pool方法。</p><p>初始化Pool时，可以指定一个最大进程数，当有新的请求提交到Pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程来执行，请看下面的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Pool</span><br><span class="line">import os,time,random</span><br><span class="line"></span><br><span class="line">def worker(msg):</span><br><span class="line">    t_start = time.time()</span><br><span class="line">    print(&quot;%s开始执行,进程号为%d&quot;%(msg,os.getpid()))</span><br><span class="line">    #random.random()随机生成0~1之间的浮点数</span><br><span class="line">    time.sleep(random.random()*2)</span><br><span class="line">    t_stop = time.time()</span><br><span class="line">    print(msg,&quot;执行完毕，耗时%0.2f&quot;%(t_stop-t_start))</span><br><span class="line"></span><br><span class="line">po=Pool(3) #定义一个进程池，最大进程数3</span><br><span class="line">for i in range(0,10):</span><br><span class="line">    #Pool.apply_async(要调用的目标,(传递给目标的参数元祖,))</span><br><span class="line">    #每次循环将会用空闲出来的子进程去调用目标</span><br><span class="line">    po.apply_async(worker,(i,))</span><br><span class="line"></span><br><span class="line">print(&quot;----start----&quot;)</span><br><span class="line">po.close() #关闭进程池，关闭后po不再接收新的请求</span><br><span class="line">po.join() #等待po中所有子进程执行完成，必须放在close语句之后</span><br><span class="line">print(&quot;-----end-----&quot;)</span><br></pre></td></tr></table></figure></p><p>运行结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">----start----</span><br><span class="line">0开始执行,进程号为21466</span><br><span class="line">1开始执行,进程号为21468</span><br><span class="line">2开始执行,进程号为21467</span><br><span class="line">0 执行完毕，耗时1.01</span><br><span class="line">3开始执行,进程号为21466</span><br><span class="line">2 执行完毕，耗时1.24</span><br><span class="line">4开始执行,进程号为21467</span><br><span class="line">3 执行完毕，耗时0.56</span><br><span class="line">5开始执行,进程号为21466</span><br><span class="line">1 执行完毕，耗时1.68</span><br><span class="line">6开始执行,进程号为21468</span><br><span class="line">4 执行完毕，耗时0.67</span><br><span class="line">7开始执行,进程号为21467</span><br><span class="line">5 执行完毕，耗时0.83</span><br><span class="line">8开始执行,进程号为21466</span><br><span class="line">6 执行完毕，耗时0.75</span><br><span class="line">9开始执行,进程号为21468</span><br><span class="line">7 执行完毕，耗时1.03</span><br><span class="line">8 执行完毕，耗时1.05</span><br><span class="line">9 执行完毕，耗时1.69</span><br><span class="line">-----end-----</span><br></pre></td></tr></table></figure></p><h3 id="Pool常用函数解析："><a href="#Pool常用函数解析：" class="headerlink" title="Pool常用函数解析："></a>Pool常用函数解析：</h3><p>1.<code>apply_async(func[, args[, kwds]])</code>：使用非阻塞方式调用func（并行执行，堵塞方式必须等待上一个进程退出才能执行下一个进程），args为传递给func的参数列表，kwds为传递给func的关键字参数列表；<br>2.<code>apply(func[, args[, kwds]])</code>：使用阻塞方式调用func<br>3.<code>close()</code>：关闭Pool，使其不再接受新的任务；<br>4.<code>terminate()</code>：不管任务是否完成，立即终止；<br>5.<code>join()</code>：主进程阻塞，等待子进程的退出， 必须在close或terminate之后使用；</p><h3 id="apply堵塞式"><a href="#apply堵塞式" class="headerlink" title="apply堵塞式"></a>apply堵塞式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Pool</span><br><span class="line">import os,time,random</span><br><span class="line"></span><br><span class="line">def worker(msg):</span><br><span class="line">    t_start = time.time()</span><br><span class="line">    print(&quot;%s开始执行,进程号为%d&quot;%(msg,os.getpid()))</span><br><span class="line">    #random.random()随机生成0~1之间的浮点数</span><br><span class="line">    time.sleep(random.random()*2)</span><br><span class="line">    t_stop = time.time()</span><br><span class="line">    print(msg,&quot;执行完毕，耗时%0.2f&quot;%(t_stop-t_start))</span><br><span class="line"></span><br><span class="line">po=Pool(3) #定义一个进程池，最大进程数3</span><br><span class="line">for i in range(0,10):</span><br><span class="line">    po.apply(worker,(i,))</span><br><span class="line"></span><br><span class="line">print(&quot;----start----&quot;)</span><br><span class="line">po.close() #关闭进程池，关闭后po不再接收新的请求</span><br><span class="line">po.join() #等待po中所有子进程执行完成，必须放在close语句之后</span><br><span class="line">print(&quot;-----end-----&quot;)</span><br></pre></td></tr></table></figure><p>运行结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">0开始执行,进程号为21532</span><br><span class="line">0 执行完毕，耗时1.91</span><br><span class="line">1开始执行,进程号为21534</span><br><span class="line">1 执行完毕，耗时1.72</span><br><span class="line">2开始执行,进程号为21533</span><br><span class="line">2 执行完毕，耗时0.50</span><br><span class="line">3开始执行,进程号为21532</span><br><span class="line">3 执行完毕，耗时1.27</span><br><span class="line">4开始执行,进程号为21534</span><br><span class="line">4 执行完毕，耗时1.05</span><br><span class="line">5开始执行,进程号为21533</span><br><span class="line">5 执行完毕，耗时1.60</span><br><span class="line">6开始执行,进程号为21532</span><br><span class="line">6 执行完毕，耗时0.25</span><br><span class="line">7开始执行,进程号为21534</span><br><span class="line">7 执行完毕，耗时0.63</span><br><span class="line">8开始执行,进程号为21533</span><br><span class="line">8 执行完毕，耗时1.21</span><br><span class="line">9开始执行,进程号为21532</span><br><span class="line">9 执行完毕，耗时0.60</span><br><span class="line">----start----</span><br><span class="line">-----end-----</span><br></pre></td></tr></table></figure></p><h2 id="进程间通信–Queue"><a href="#进程间通信–Queue" class="headerlink" title="进程间通信–Queue"></a>进程间通信–Queue</h2><p>Process之间有时需要通信，操作系统提供了很多机制来实现进程间的通信。</p><p>可以使用multiprocessing模块的Queue实现多进程之间的数据传递，Queue本身是一个消息列队程序，首先用一个小实例来演示一下Queue的工作原理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line">from multiprocessing import Queue</span><br><span class="line">q=Queue(3) #初始化一个Queue对象，最多可接收三条put消息</span><br><span class="line">q.put(&quot;消息1&quot;)</span><br><span class="line">q.put(&quot;消息2&quot;)</span><br><span class="line">print(q.full())  #False</span><br><span class="line">q.put(&quot;消息3&quot;)</span><br><span class="line">print(q.full()) #True</span><br><span class="line"></span><br><span class="line">#因为消息列队已满下面的try都会抛出异常，第一个try会等待2秒后再抛出异常，第二个Try会立刻抛出异常</span><br><span class="line">try:</span><br><span class="line">    q.put(&quot;消息4&quot;,True,2)</span><br><span class="line">except:</span><br><span class="line">    print(&quot;消息列队已满，现有消息数量:%s&quot;%q.qsize())</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    q.put_nowait(&quot;消息4&quot;)</span><br><span class="line">except:</span><br><span class="line">    print(&quot;消息列队已满，现有消息数量:%s&quot;%q.qsize())</span><br><span class="line"></span><br><span class="line">#推荐的方式，先判断消息列队是否已满，再写入</span><br><span class="line">if not q.full():</span><br><span class="line">    q.put_nowait(&quot;消息4&quot;)</span><br><span class="line"></span><br><span class="line">#读取消息时，先判断消息列队是否为空，再读取</span><br><span class="line">if not q.empty():</span><br><span class="line">    for i in range(q.qsize()):</span><br><span class="line">        print(q.get_nowait())</span><br></pre></td></tr></table></figure></p><p>运行结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">False</span><br><span class="line">True</span><br><span class="line">消息列队已满，现有消息数量:3</span><br><span class="line">消息列队已满，现有消息数量:3</span><br><span class="line">消息1</span><br><span class="line">消息2</span><br><span class="line">消息3</span><br></pre></td></tr></table></figure></p><p>初始化Queue()对象时（例如：q=Queue()），若括号中没有指定最大可接收的消息数量，或数量为负值，那么就代表可接受的消息数量没有上限（直到内存的尽头）；<br>1.Queue.qsize()：返回当前队列包含的消息数量；<br>2.Queue.empty()：如果队列为空，返回True，反之False ；<br>3.Queue.full()：如果队列满了，返回True,反之False；<br>4.Queue.get([block[, timeout]])：获取队列中的一条消息，然后将其从列队中移除，block默认值为True；<br>5.Queue.get_nowait()：相当Queue.get(False)；<br>6.Queue.put(item,[block[, timeout]])：将item消息写入队列，block默认值为True；<br>7.Queue.put_nowait(item)：相当Queue.put(item, False)；</p><p>###Queue实例<br>我们以Queue为例，在父进程中创建两个子进程，一个往Queue里写数据，一个从Queue里读数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process, Queue</span><br><span class="line">import os, time, random</span><br><span class="line"></span><br><span class="line"># 写数据进程执行的代码:</span><br><span class="line">def write(q):</span><br><span class="line">    for value in [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]:</span><br><span class="line">        print &apos;Put %s to queue...&apos; % value</span><br><span class="line">        q.put(value)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"># 读数据进程执行的代码:</span><br><span class="line">def read(q):</span><br><span class="line">    while True:</span><br><span class="line">        if not q.empty():</span><br><span class="line">            value = q.get(True)</span><br><span class="line">            print &apos;Get %s from queue.&apos; % value</span><br><span class="line">            time.sleep(random.random())</span><br><span class="line">        else:</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    # 父进程创建Queue，并传给各个子进程：</span><br><span class="line">    q = Queue()</span><br><span class="line">    pw = Process(target=write, args=(q,))</span><br><span class="line">    pr = Process(target=read, args=(q,))</span><br><span class="line">    # 启动子进程pw，写入:</span><br><span class="line">    pw.start()    </span><br><span class="line">    # 等待pw结束:</span><br><span class="line">    pw.join()</span><br><span class="line">    # 启动子进程pr，读取:</span><br><span class="line">    pr.start()</span><br><span class="line">    pr.join()</span><br><span class="line">    # pr进程里是死循环，无法等待其结束，只能强行终止:</span><br><span class="line">    print &apos;&apos;</span><br><span class="line">    print &apos;所有数据都写入并且读完&apos;</span><br></pre></td></tr></table></figure></p><h3 id="进程池中的Queue"><a href="#进程池中的Queue" class="headerlink" title="进程池中的Queue"></a>进程池中的Queue</h3><p>如果要使用Pool创建进程，就需要使用multiprocessing.Manager()中的Queue()，而不是multiprocessing.Queue()，否则会得到一条如下的错误信息：</p><p>RuntimeError: Queue objects should only be shared between processes through inheritance.</p><p>下面的实例演示了进程池中的进程如何通信：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line"></span><br><span class="line">#修改import中的Queue为Manager</span><br><span class="line">from multiprocessing import Manager,Pool</span><br><span class="line">import os,time,random</span><br><span class="line"></span><br><span class="line">def reader(q):</span><br><span class="line">    print(&quot;reader启动(%s),父进程为(%s)&quot;%(os.getpid(),os.getppid()))</span><br><span class="line">    for i in range(q.qsize()):</span><br><span class="line">        print(&quot;reader从Queue获取到消息：%s&quot;%q.get(True))</span><br><span class="line"></span><br><span class="line">def writer(q):</span><br><span class="line">    print(&quot;writer启动(%s),父进程为(%s)&quot;%(os.getpid(),os.getppid()))</span><br><span class="line">    for i in &quot;dongGe&quot;:</span><br><span class="line">        q.put(i)</span><br><span class="line"></span><br><span class="line">if __name__==&quot;__main__&quot;:</span><br><span class="line">    print(&quot;(%s) start&quot;%os.getpid())</span><br><span class="line">    q=Manager().Queue() #使用Manager中的Queue来初始化</span><br><span class="line">    po=Pool()</span><br><span class="line">    #使用阻塞模式创建进程，这样就不需要在reader中使用死循环了，可以让writer完全执行完成后，再用reader去读取</span><br><span class="line">    po.apply(writer,(q,))</span><br><span class="line">    po.apply(reader,(q,))</span><br><span class="line">    po.close()</span><br><span class="line">    po.join()</span><br><span class="line">    print(&quot;(%s) End&quot;%os.getpid())</span><br></pre></td></tr></table></figure></p><p>运行结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(21156) start</span><br><span class="line">writer启动(21162),父进程为(21156)</span><br><span class="line">reader启动(21162),父进程为(21156)</span><br><span class="line">reader从Queue获取到消息：d</span><br><span class="line">reader从Queue获取到消息：o</span><br><span class="line">reader从Queue获取到消息：n</span><br><span class="line">reader从Queue获取到消息：g</span><br><span class="line">reader从Queue获取到消息：G</span><br><span class="line">reader从Queue获取到消息：e</span><br><span class="line">(21156) End</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍和Python进程相关的内容。&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://likernel.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python实现链表</title>
    <link href="http://likernel.github.io/2017/08/15/python%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8/"/>
    <id>http://likernel.github.io/2017/08/15/python实现链表/</id>
    <published>2017-08-15T03:08:28.000Z</published>
    <updated>2018-02-11T15:36:52.118Z</updated>
    
    <content type="html"><![CDATA[<p>之前只是介绍过链表这种数据结构，但是，没有进行详细的讲解，虽然这种数据结构在很多时候，特别是在读取元素的时候，并不是显得很高效，但是仍然值得我们学习，链表问题也是面试中常见的问题，比如：链表的逆置，因此深入的学习这种数据结构很有必要。<br><a id="more"></a></p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表是实现了数据之间保持逻辑顺序，但存储空间不必按顺序的方法。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>1.节点：每一个节点有两个域，左边部份叫值域，用于存放用户数据；右边叫指针域，一般是存储着到下一个元素的指针。<br>2.head节点：head是一个特殊的节点，head节点永远指向第一个节点。<br>3.tail节点：tail节点也是一个特殊的节点，tail节点永远指向最后一个节点。<br>4.None：链表中最后一个节点指针域的指针指向None值。</p><h2 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h2><p>1.LinkedList() 创建空链表，不需要参数，返回值是空链表<br>2.is_empty() 测试链表是否为空，不需要参数，返回值是布尔值<br>3.append(data) 在尾部增加一个元素作为列表最后一个。参数是要追加的元素，无返回值<br>4.iter() 遍历链表，无参数，无返回值，此方法一般是一个生成器<br>5.insert(idx,value) 插入一个元素，参数为插入元素的索引和值<br>6.remove(idx)移除1个元素，参数为要移除的元素或索引，并修改链表<br>7.size() 返回链表的元素数，不需要参数，返回值是个整数<br>8.find(item) 查找链表某元素，参数为要查找的元素或索引，返回是布尔值</p><p>#节点类<br>python用类来实现链表的数据结构，节点类中包含两个属性，数据和指针：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Node:</span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.next = None</span><br></pre></td></tr></table></figure></p><p>此节点类只有一个构建函数，接收一个数据参数，其中next表示指针域的指针，实例化后得到一个节点对象，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node = Node(4)</span><br></pre></td></tr></table></figure></p><p>备注：此节点对象数据为4，指针指向None。</p><h1 id="链表类"><a href="#链表类" class="headerlink" title="链表类"></a>链表类</h1><p>创建空链表，不需要参数，返回值是空链表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class LinkedList:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.head = None</span><br><span class="line">        self.tail = None</span><br></pre></td></tr></table></figure></p><p>此类实例后会生成一个链表对象，初始化了head和tail节点，且两节点都指向None，实例化代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">link_list = LinkedList()</span><br></pre></td></tr></table></figure></p><h1 id="is-empty方法"><a href="#is-empty方法" class="headerlink" title="is_empty方法"></a>is_empty方法</h1><p>is_empty方法检查链表是否是一个空链表，这个方法只需要检查head节点是否指向None即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def is_empty(self):</span><br><span class="line">        return self.head is None</span><br></pre></td></tr></table></figure></p><p>#append方法<br>append方法表示增加元素到链表，这和insert方法不同，前者使新增加的元素成为链表中第一个节点，而后者是根据索引值来判断插入到链表的哪个位置。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def append(self, data):</span><br><span class="line">        node = Node(data)</span><br><span class="line">        if self.head is None:</span><br><span class="line">            self.head = node</span><br><span class="line">            self.tail = node</span><br><span class="line">        else:</span><br><span class="line">            self.tail.next = node</span><br><span class="line">            self.tail = node</span><br></pre></td></tr></table></figure></p><h1 id="iter方法实现"><a href="#iter方法实现" class="headerlink" title="iter方法实现"></a>iter方法实现</h1><p>iter方法用来遍历链表，分两种情况：<br>1.空链表<br>2.遍历链表时从head开始，直到一个节点的next指向None结束，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def iter(self):</span><br><span class="line">        if not self.head:</span><br><span class="line">            return</span><br><span class="line">        cur = self.head</span><br><span class="line">        yield cur.data</span><br><span class="line">        while cur.next:</span><br><span class="line">            cur = cur.next</span><br><span class="line">            yield cur.data</span><br></pre></td></tr></table></figure></p><p>备注：使用局部变量cur指向head,把对应的data yield出来，再对cur的next指针指向的对象做while循环，直到next指向None，这样就遍历了链表。</p><h1 id="insert方法"><a href="#insert方法" class="headerlink" title="insert方法"></a>insert方法</h1><p>采用遍历的方式找到需要插入，改变对应的指针域所指的位置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def insert(self, idx, value):</span><br><span class="line">        cur = self.head</span><br><span class="line">        cur_idx = 0</span><br><span class="line">        if cur is None:</span><br><span class="line">            raise Exception(&apos;The list is an empty list&apos;)</span><br><span class="line">        while cur_idx &lt; idx-1:</span><br><span class="line">            cur = cur.next</span><br><span class="line">            if cur is None:</span><br><span class="line">                raise Exception(&apos;list length less than index&apos;)</span><br><span class="line">            cur_idx += 1</span><br><span class="line">        node = Node(value)</span><br><span class="line">        node.next = cur.next</span><br><span class="line">        cur.next = node</span><br><span class="line">        if node.next is None:</span><br><span class="line">            self.tail = node</span><br></pre></td></tr></table></figure></p><p>#remove方法<br>remove方法接收一个idx参数，表示要删除节点的索引，此方法要考虑以下几种情况：<br>1.空链表，直接抛出异常<br>2.删除第一个节点时，移动head到删除节点的next指针指向的对象<br>3.链表只有一个节点时，把head与tail都指向None即可<br>4.删除最后一个节点时，需要移动tail到上一个节点<br>5.遍历链表时要判断给定的索引是否大于链表的长度，如果大于则抛出异常信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def remove(self, idx):</span><br><span class="line">       cur = self.head</span><br><span class="line">       cur_idx = 0</span><br><span class="line">       if self.head is None:  # 空链表时</span><br><span class="line">           raise Exception(&apos;The list is an empty list&apos;)</span><br><span class="line">       while cur_idx &lt; idx-1:</span><br><span class="line">           cur = cur.next</span><br><span class="line">           if cur is None:</span><br><span class="line">               raise Exception(&apos;list length less than index&apos;)</span><br><span class="line">           cur_idx += 1</span><br><span class="line">       if idx == 0:   # 当删除第一个节点时</span><br><span class="line">           self.head = cur.next</span><br><span class="line">           cur = cur.next</span><br><span class="line">           return</span><br><span class="line">       if self.head is self.tail:   # 当只有一个节点的链表时</span><br><span class="line">           self.head = None</span><br><span class="line">           self.tail = None</span><br><span class="line">           return</span><br><span class="line">       cur.next = cur.next.next</span><br><span class="line">       if cur.next is None:  # 当删除的节点是链表最后一个节点时</span><br><span class="line">           self.tail = cur</span><br></pre></td></tr></table></figure></p><h1 id="size方法"><a href="#size方法" class="headerlink" title="size方法"></a>size方法</h1><p>size函数不接收参数，返回链表中节点的个数，遍历链表，用一个累加器count来计算节点的个数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def size(self):</span><br><span class="line">        current = self.head</span><br><span class="line">        count = 0</span><br><span class="line">        if current is None:</span><br><span class="line">            return &apos;The list is an empty list&apos;</span><br><span class="line">        while current is not None:</span><br><span class="line">            count += 1</span><br><span class="line">            current = current.next</span><br><span class="line">        return count</span><br></pre></td></tr></table></figure></p><h1 id="find方法"><a href="#find方法" class="headerlink" title="find方法"></a>find方法</h1><p>find函数接收一个item参数，表示查找节点中数据域的值。find方法遍历链表，每到一个节点把当前节点的data值与item作比较：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def find(self, item):</span><br><span class="line">        current = self.head</span><br><span class="line">        found = False</span><br><span class="line">        while current is not None and not found:</span><br><span class="line">            if current.data == item:</span><br><span class="line">                found = True</span><br><span class="line">            else:</span><br><span class="line">                current = current.next</span><br><span class="line">        return found</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前只是介绍过链表这种数据结构，但是，没有进行详细的讲解，虽然这种数据结构在很多时候，特别是在读取元素的时候，并不是显得很高效，但是仍然值得我们学习，链表问题也是面试中常见的问题，比如：链表的逆置，因此深入的学习这种数据结构很有必要。&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://likernel.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://likernel.github.io/2017/08/14/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://likernel.github.io/2017/08/14/并查集/</id>
    <published>2017-08-14T08:43:10.000Z</published>
    <updated>2018-02-11T15:30:15.720Z</updated>
    
    <content type="html"><![CDATA[<p>并查集（Union-Find）是用于解决动态连通性类问题的一种数据结构。<br><a id="more"></a></p><h1 id="动态连通性问题"><a href="#动态连通性问题" class="headerlink" title="动态连通性问题"></a>动态连通性问题</h1><p>动态连通性问题是一个非常基础的计算性问题，而且它在现实世界中的应用很广泛，庞大的电脑网络、数以亿计的社交网络中的人类、数学集合中的元素、计算机程序中的变量、照片中的像素，都会涉及到动态连通性。</p><p>1.这类问题的输入是一列整数对，每个整数都表示一个某种类型的对象，一对整数“p q”表示的含义是“p和q相连”。</p><p>2.“相连”是一种等价关系<br>1） 自反性（p与p相连接）；<br>2） 对称性（若p连接到q，那么q也连接到p）；<br>3） 传递性（若p连接到q，q连接到r，则p连接到r）。</p><p>3.等价关系将对象分成多个等价类，它们构成多个集合，称为“连通组件”（Connected Components）。</p><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>对于一组数据，并查集主要支持两个动作，回答一个问题。</p><h3 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h3><p>1.union(p,q)：将p,q连接。<br>2.find(p)：查找p。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>isConnected(p,q)：检测p,q是否连接并返回布尔值。</p><p>举个例子：</p><p><img src="/assets/images/2017/08/union.png" alt=""></p><p>我们可以通过union操作，实现上图的连接，形成了两个连通分量，或称为一个组。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="Quick-Find实现"><a href="#Quick-Find实现" class="headerlink" title="Quick-Find实现"></a>Quick-Find实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">id = []</span><br><span class="line">count = 0</span><br><span class="line"></span><br><span class="line">def unionFind(n):</span><br><span class="line">    count = n</span><br><span class="line">    for i in xrange(count):</span><br><span class="line">        id[i] = i</span><br><span class="line"></span><br><span class="line">def isConnected(p,q):</span><br><span class="line">    return find(p) == find(q)</span><br><span class="line"></span><br><span class="line">def find(p):</span><br><span class="line">    return id[p]</span><br><span class="line"></span><br><span class="line">def union(p, q):</span><br><span class="line">    pid = find(p)</span><br><span class="line">    qid = find(q)</span><br><span class="line"></span><br><span class="line">    for i in xrange(count):</span><br><span class="line">         if id[i] == pid:</span><br><span class="line">             id[i] = qid</span><br></pre></td></tr></table></figure><p>备注：上面的实现，只给出了每个函数的实现，其中，有一点需要说明，就是id这个数组。初始化时，每个元素都是指向自己，union操作时，循环遍历id数组，将qid指向pid这条链上的最后一个元素。</p><p>具体过程如下所示：</p><p><img src="/assets/images/2017/08/quickfind.png" alt=""></p><h2 id="Quick-Union实现"><a href="#Quick-Union实现" class="headerlink" title="Quick-Union实现"></a>Quick-Union实现</h2><p>上面的Quick-find实现在规模增大时，会面临性能问题，其主要来源是union操作需要遍历数组，为了改善性能，需要避免执行union操作时遍历数组，Quick-Union实现达到了这一目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">parent = []</span><br><span class="line">count = 0</span><br><span class="line"></span><br><span class="line">def unionFind(n):</span><br><span class="line">    count = n</span><br><span class="line">    for i in xrange(count):</span><br><span class="line">        parent[i] = i</span><br><span class="line"></span><br><span class="line">def isConnected(p,q):</span><br><span class="line">    return find(p) == find(q)</span><br><span class="line"></span><br><span class="line">def find(p):</span><br><span class="line">    while p!=parent[p]:</span><br><span class="line">        p = parent[p]</span><br><span class="line">    return p</span><br><span class="line"></span><br><span class="line">def union(p, q):</span><br><span class="line">    proot = find(p)</span><br><span class="line">    qroot = find(q)</span><br><span class="line"></span><br><span class="line">    if proot != qroot:</span><br><span class="line">        parent[proot] = qroot</span><br></pre></td></tr></table></figure><p>具体过程如下所示：</p><p><img src="/assets/images/2017/08/quickunipn.png" alt=""></p><h2 id="Quick-Union优化"><a href="#Quick-Union优化" class="headerlink" title="Quick-Union优化"></a>Quick-Union优化</h2><h2 id="基于元素个数优化"><a href="#基于元素个数优化" class="headerlink" title="基于元素个数优化"></a>基于元素个数优化</h2><p>引入一个num[i]，用来记录以i为根的集合中元素个数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">num = []</span><br><span class="line"></span><br><span class="line">def unionFind(n):</span><br><span class="line">    count = n</span><br><span class="line">    for i in xrange(count):</span><br><span class="line">        parent[i] = i</span><br><span class="line">        num[i] = 1</span><br></pre></td></tr></table></figure></p><p>始终保持元素少的根节点指向元素多的根节点，这样有很大的概率可以维护树的高度增长的不是那么快。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def union(p, q):</span><br><span class="line">    proot = find(p)</span><br><span class="line">    qroot = find(q)</span><br><span class="line"></span><br><span class="line">    if num[proot] &lt; num[qroot]:</span><br><span class="line">        parent[proot] = qroot</span><br><span class="line">        num[qroot] += num[proot]</span><br><span class="line"></span><br><span class="line">    else:</span><br><span class="line">        parent[qroot] = proot</span><br><span class="line">        num[proot] += num[qroot]</span><br></pre></td></tr></table></figure></p><h2 id="基于rank的优化"><a href="#基于rank的优化" class="headerlink" title="基于rank的优化"></a>基于rank的优化</h2><p>在上述的优化过程中，只是有很大的概率可以维护树的高度增长的不是那么快。实际上并不准确，更多的时候我们采用的是基于rank的优化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rank = []</span><br><span class="line"></span><br><span class="line">def unionFind(n):</span><br><span class="line">    count = n</span><br><span class="line">    for i in xrange(count):</span><br><span class="line">        parent[i] = i</span><br><span class="line">        rank[i] = 1</span><br></pre></td></tr></table></figure></p><p>和上面一种优化相比，区别在于，这里维护的是真正的树的深度，树深小的指向树深大的，只有当相等的时候树深才会加1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def union(p, q):</span><br><span class="line">    proot = find(p)</span><br><span class="line">    qroot = find(q)</span><br><span class="line"></span><br><span class="line">    if rank[proot] &lt; rank[qroot]:</span><br><span class="line">        parent[proot] = qroot</span><br><span class="line">    elif rank[qroot] &lt; rank[proot]:</span><br><span class="line">        parent[qroot] = proot</span><br><span class="line">    else:</span><br><span class="line">        parent[proot] = qroot</span><br><span class="line">        rank[qroot] += 1</span><br></pre></td></tr></table></figure></p><h2 id="路径压缩（Path-Compression）"><a href="#路径压缩（Path-Compression）" class="headerlink" title="路径压缩（Path Compression）"></a>路径压缩（Path Compression）</h2><p>先实现第一种路径压缩优化，实际上只需要对find(p)进行一个修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def find(p):</span><br><span class="line">    while p!=parent[p]:</span><br><span class="line">        parent[p] = parent[parent[p]]</span><br><span class="line">        p = parent[p]</span><br><span class="line">    return p</span><br></pre></td></tr></table></figure></p><p>具体过程如下：</p><p><img src="/assets/images/2017/08/pathcompression.png" alt=""></p><p>可以看到，路径的确被压缩了，但是这仍然不是最优的压缩路径，最优的情况下是如下图这种压缩方式：</p><p><img src="/assets/images/2017/08/compression.png" alt=""></p><p>使用递归实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def find(p):</span><br><span class="line">    if p!=parent[p]:</span><br><span class="line">        parent[p] = find(parent[p])</span><br><span class="line">    return p</span><br></pre></td></tr></table></figure></p><p>以上内容，便是并查集的内容，后续会更新一些笔面试题目，加深应用和理解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并查集（Union-Find）是用于解决动态连通性类问题的一种数据结构。&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://likernel.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="并查集" scheme="http://likernel.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
</feed>
