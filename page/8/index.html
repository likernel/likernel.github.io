<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>likernel</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="likernel的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="likernel">
<meta property="og:url" content="http://likernel.github.io/page/8/index.html">
<meta property="og:site_name" content="likernel">
<meta property="og:description" content="likernel的个人博客">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="likernel">
<meta name="twitter:description" content="likernel的个人博客">
<meta name="twitter:creator" content="@https:&#x2F;&#x2F;twitter.com&#x2F;likernel">
  
    <link rel="alternate" href="/atom.xml" title="likernel" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">likernel</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">主页</a>
        
          <a class="main-nav-link" href="/archives">文章归档</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://likernel.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-leetcode-4-Sum" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/23/leetcode-4-Sum/" class="article-date">
  <time datetime="2017-07-23T08:18:35.000Z" itemprop="datePublished">2017-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/23/leetcode-4-Sum/">leetcode--4 Sum</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="4-Sum"><a href="#4-Sum" class="headerlink" title="4 Sum"></a>4 Sum</h3><p>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p>
<p>The solution set must not contain duplicate quadruplets.</p>
        
          <p class="article-more-link">
            <a href="/2017/07/23/leetcode-4-Sum/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://likernel.github.io/2017/07/23/leetcode-4-Sum/" data-id="cjdiz17xp002ggkulk2zb5lpf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-leetcode-3-Sum-Closest" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/23/leetcode-3-Sum-Closest/" class="article-date">
  <time datetime="2017-07-23T08:16:29.000Z" itemprop="datePublished">2017-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/23/leetcode-3-Sum-Closest/">leetcode--3 Sum Closest</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="3-Sum-Closest"><a href="#3-Sum-Closest" class="headerlink" title="3 Sum Closest"></a>3 Sum Closest</h3><p>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<p><strong>Example:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">For example, given array S = &#123;-1 2 1 -4&#125;, and target = 1.</span><br><span class="line">The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></table></figure></p>
<p><strong>思路：</strong><br>思路和3sum类似，还是找一个基准值和两个指针lp和rp不过有些地方简化了，只需要获得一个值。因此，对应的组合不用存取，只需要不断的更新最接近的值即可。</p>
<p><strong>实现：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def threeSumClosest(nums, target):</span><br><span class="line">        if not len(nums):  </span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        nums.sort()</span><br><span class="line">        res = nums[0] + nums[1] + nums[2]   </span><br><span class="line">        for i in range(len(nums) - 2):  </span><br><span class="line">            lp = i + 1  </span><br><span class="line">            rp = len(nums) - 1  </span><br><span class="line">            while lp &lt; rp:  </span><br><span class="line">                closest = nums[i] + nums[lp] + nums[rp]  </span><br><span class="line">                if abs(closest - target) &lt; abs(res - target):  </span><br><span class="line">                    res = closest  </span><br><span class="line">                if closest &lt; target:  </span><br><span class="line">                    lp += 1  </span><br><span class="line">                elif closest &gt; target:  </span><br><span class="line">                    rp -= 1  </span><br><span class="line">                else:  </span><br><span class="line">                    lp += 1  </span><br><span class="line">                    rp -= 1  </span><br><span class="line">        return res</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://likernel.github.io/2017/07/23/leetcode-3-Sum-Closest/" data-id="cjdiz17xd002dgkul3w2gvoiz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-leetcode-3-Sum" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/23/leetcode-3-Sum/" class="article-date">
  <time datetime="2017-07-23T08:12:02.000Z" itemprop="datePublished">2017-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/23/leetcode-3-Sum/">leetcode--3 Sum</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="3-Sum"><a href="#3-Sum" class="headerlink" title="3 Sum"></a>3 Sum</h3><p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p>The solution set must not contain duplicate triplets.</p>
        
          <p class="article-more-link">
            <a href="/2017/07/23/leetcode-3-Sum/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://likernel.github.io/2017/07/23/leetcode-3-Sum/" data-id="cjdiz17zc0055gkulzx3f5api" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数组/">数组</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-leetcode-Container-With-Most-Water" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/23/leetcode-Container-With-Most-Water/" class="article-date">
  <time datetime="2017-07-23T08:06:25.000Z" itemprop="datePublished">2017-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/23/leetcode-Container-With-Most-Water/">leetcode--Container With Most Water</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Container-With-Most-Water"><a href="#Container-With-Most-Water" class="headerlink" title="Container With Most Water"></a>Container With Most Water</h3><p>Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p><strong>Note:</strong></p>
<p>You may not slant the container and n is at least 2.</p>
        
          <p class="article-more-link">
            <a href="/2017/07/23/leetcode-Container-With-Most-Water/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://likernel.github.io/2017/07/23/leetcode-Container-With-Most-Water/" data-id="cjdiz17xr002igkul9hstvxnw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-选择排序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/23/选择排序/" class="article-date">
  <time datetime="2017-07-23T00:13:36.000Z" itemprop="datePublished">2017-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/23/选择排序/">选择排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>The algorithm divides the input list into two parts: the sublist of items already sorted, which is built up from left to right at the front (left) of the list, and the sublist of items remaining to be sorted that occupy the rest of the list.</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。时间复杂度为O(n^2)。</p>
<p>python实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def findSmallest(arr):</span><br><span class="line">        smallest = arr[0]     #最小的数</span><br><span class="line">        smallest_index = 0    #最小的数的索引</span><br><span class="line">        for i in range(1,len(arr)):</span><br><span class="line">            if arr[i] &lt; smallest:</span><br><span class="line">                smallest = arr[i]</span><br><span class="line">                smallest_index = i</span><br><span class="line">        return smallest_index</span><br><span class="line"></span><br><span class="line">def selection_sort(arr):      #对数组进行排序</span><br><span class="line">        new_arr = []</span><br><span class="line">        for i in range(len(arr)):</span><br><span class="line">            smallest = findSmallest(arr)</span><br><span class="line">            new_arr.append(arr.pop(smallest))</span><br><span class="line">        return new_arr</span><br></pre></td></tr></table></figure></p>
<p><strong>参考书目：</strong><br>[^1]: 《算法图解》【美】Aditya Bhargava. 编著</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://likernel.github.io/2017/07/23/选择排序/" data-id="cjdiz17z20050gkulsnn5ep9o" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/排序/">排序</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-leetcode-Median-of-Two-Sorted-Arrays" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/22/leetcode-Median-of-Two-Sorted-Arrays/" class="article-date">
  <time datetime="2017-07-22T00:14:52.000Z" itemprop="datePublished">2017-07-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/22/leetcode-Median-of-Two-Sorted-Arrays/">leetcode--Median of Two Sorted Arrays</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">The median is 2.0</span><br></pre></td></tr></table></figure></p>
<p><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">The median is (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure></p>
<p><strong>概念：</strong></p>
<p>median：首先需要了解何为median，即我们常说的中位数（针对排序数组来说的），如果为奇数就是正中间的那个数，如果为偶数就是中间的两个数的平均数，like Example 1和Example 2.</p>
<p><strong>思路：</strong></p>
<p>这个题乍看比较容易，但是在LeetCode中给出的Difficulty是hard，关键就在于它对时间复杂度有要求，为O(log (m+n))。对数时间我首先想到的是二分查找，说明该算法的效率一定要与之类似，但又有所限制，确实很难。处理时不能将两个数组合并，不然时间复杂度就提升为线性时间O(m+n)。但我们每次处理需要类似二分查找那样每次平均要处理一半的数。</p>
<p>1.这里我们借用findKthNumber的思想。先实现findKthNumber，如果是偶数个，则把中间2个加起来平均，奇数就用中间的。</p>
<p>2.为了达到对数级的复杂度，我们可以这样：每次在A，B取前k/2个元素。有以下几种情况：</p>
<p>1） A的元素不够k/2，我们可以丢弃B前k/2个元素。反之亦然。</p>
<p>反证法：<br>假设第K大在B的前k/2中，例如位置在索引m(m&lt;=k/2-1)那么A必然拥有前k中的k -(m+1)个元素，而m&lt;=k/2-1,则m+1&lt;=k/2,k-(m+1)&gt;k/2与条件：A的元素不够k/2矛盾，所以假设不成立，得证。</p>
<p>2）A[mid] &lt; B[mid] (mid是k/2 -1索引处的元素）。这种情况下，我们可以丢弃A前k/2。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">反证法：</span><br><span class="line">假设第K大在A的前k/2中记为maxK，例如位置在索引m(m&lt;= k/2-1)。</span><br><span class="line">那么B必然拥有前k中的k-(m+1)个元素，</span><br><span class="line">而m&lt;=k/2-1,则m+1 &lt;=k/2,k-(m+1)&gt;k/2，推出B[mid]&lt;=maxK。</span><br><span class="line">而A[mid] &gt;= maxK。 推出 A[mid]&gt;=B[mid], 与题设矛盾。</span><br></pre></td></tr></table></figure></p>
<p>3.知道上面两个结论对我们很重要。接下来，使用D&amp;C来解决一下这个问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.基线条件（有两种情况）：</span><br><span class="line">1）有一个数组为空</span><br><span class="line">2）数组都不为空，k=1（这时候取两个数组最小的元素即可）</span><br><span class="line">2.递归条件：</span><br><span class="line">A[mid] &lt; B[mid]，丢弃A前k/2。（包含两层意思：A或B舍弃k/2;</span><br><span class="line">k做相应变化，k-mid）</span><br></pre></td></tr></table></figure></p>
<p>源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def findMedianSortedArrays(num1, num2):</span><br><span class="line">    len_sum = len(num1)+len(num2)</span><br><span class="line">    if(len_sum % 2 == 1):</span><br><span class="line">        return findKth(num1, num2, len_sum/2+1)</span><br><span class="line">    else:</span><br><span class="line">        return (findKth(num1, num2, len_sum/2)+findKth(num1, num2, len_sum/2+1))/2.0</span><br><span class="line"></span><br><span class="line">def findKth(A, B, k):</span><br><span class="line">    len1,len2 = len(A),len(B)</span><br><span class="line">    if len(A)==0:</span><br><span class="line">        return B[k-1]</span><br><span class="line">    if len(B)==0:</span><br><span class="line">        return A[k-1]</span><br><span class="line">    if k == 1:</span><br><span class="line">        return min(A[0],B[0])</span><br><span class="line"></span><br><span class="line">    mid1 = min(k/2,len1)</span><br><span class="line">    mid2 = min(k/2,len2)</span><br><span class="line"></span><br><span class="line">    if A[mid1-1] &lt; B[mid2-1]:</span><br><span class="line">        C = A[mid1:len1]</span><br><span class="line">        return findKth(C,B,k-mid1)</span><br><span class="line">    else:</span><br><span class="line">        C = B[mid2:len2]</span><br><span class="line">        return findKth(A,C,k-mid2)</span><br><span class="line"></span><br><span class="line">print findMedianSortedArrays([1,2],[3,4])</span><br></pre></td></tr></table></figure></p>
<p>备注：不使用D&amp;C，使用循环一样可以实现。这里给出一种使用循环的解法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def findMedianSortedArrays(nums1, nums2):</span><br><span class="line">        len_sum = len(nums1)+len(nums2)</span><br><span class="line">        if(len_sum % 2 == 1):</span><br><span class="line">            return findKth(nums1, nums2, len_sum/2+1)</span><br><span class="line">        return (findKth(nums1, nums2, len_sum/2)+findKth(nums1, nums2, len_sum/2+1))/2.0</span><br><span class="line"></span><br><span class="line">    def findKth(self, A, B, k):</span><br><span class="line">        m,n = len(A), len(B)</span><br><span class="line">        if m &gt; n:</span><br><span class="line">            return findKth(B, A, k)</span><br><span class="line"></span><br><span class="line">        left, right = 0, m</span><br><span class="line">        while left &lt; right:</span><br><span class="line">            mid = left + (right-left)/2</span><br><span class="line">            if 0 &lt;= k-1-mid &lt; n and A[mid] &gt;= B[k-1-mid]:</span><br><span class="line">                right = mid</span><br><span class="line">            else:</span><br><span class="line">                left = mid+1</span><br><span class="line">        Ai_minus1 = A[left - 1] if left - 1 &gt;= 0 else float(&quot;-inf&quot;)</span><br><span class="line">        Bj = B[k - 1 - left] if k - 1 - left &gt;= 0 else float(&quot;-inf&quot;)</span><br><span class="line">        return max(Ai_minus1,Bj)</span><br></pre></td></tr></table></figure></p>
<p>注：float(“-inf”)表示负无穷。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://likernel.github.io/2017/07/22/leetcode-Median-of-Two-Sorted-Arrays/" data-id="cjdiz17xw002qgkulfgq66be6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-leetcode-Two-Sum" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/21/leetcode-Two-Sum/" class="article-date">
  <time datetime="2017-07-21T04:12:52.000Z" itemprop="datePublished">2017-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/21/leetcode-Two-Sum/">leetcode--Two Sum</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Two-Sum"><a href="#Two-Sum" class="headerlink" title="Two Sum"></a>Two Sum</h3><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p><strong>Example:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure></p>
        
          <p class="article-more-link">
            <a href="/2017/07/21/leetcode-Two-Sum/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://likernel.github.io/2017/07/21/leetcode-Two-Sum/" data-id="cjdiz17y60035gkulv7sb5lxx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-散列表" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/21/散列表/" class="article-date">
  <time datetime="2017-07-21T03:51:56.000Z" itemprop="datePublished">2017-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/21/散列表/">散列表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>A hash table (hash map) is a data structure which implements an associative array abstract data type, a structure that can map keys to values. A hash table uses a hash function to compute an index into an array of buckets or slots, from which the desired value can be found.</p>
<h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><p>散列函数是这样的函数，无论你给它什么数据，它都会给你一个数字。用专业的话说，“散列函数将输入映射到数字。”</p>
<ol>
<li>散列函数总是将同样的输入映射到相同的索引。</li>
<li>散列函数总是将不同的输入映射到不同的索引。（有问题，暂且先这样理解）</li>
<li>散列表知道数组有多大，只返回有效的索引。</li>
</ol>
<p>任何一门优秀的语言都提供了散列表的实现，python提供的散列表的实现为<strong>字典</strong>。可以通过dict来创建散列表。像之前leetcode中的Two Sum，最快捷的方法就是使用dict。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#第一种创建方法</span><br><span class="line">hash_table = dict()</span><br><span class="line">#第二种创建方法</span><br><span class="line">hash_table = &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>散列表的用途十分广泛，下面介绍一下它的用途。</p>
<h4 id="将散列表用于查找"><a href="#将散列表用于查找" class="headerlink" title="将散列表用于查找"></a>将散列表用于查找</h4><p>散列表常被用于大海捞针式的查找。例如，我们常见的DNS解析（将网址映射到IP地址），散列表就是实现这种功能的方式之一。</p>
<p>散列表用于查找,大致分为两个步骤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 创建映射</span><br><span class="line">2. 查找</span><br></pre></td></tr></table></figure></p>
<h4 id="防止重复"><a href="#防止重复" class="headerlink" title="防止重复"></a>防止重复</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 创建映射</span><br><span class="line">2. 检查是否重复</span><br></pre></td></tr></table></figure>
<h4 id="将散列表用作缓存"><a href="#将散列表用作缓存" class="headerlink" title="将散列表用作缓存"></a>将散列表用作缓存</h4><p>缓存是一种常用的加速方式，所有的大型网站都使用缓存，而缓存的数据就是存储在散列表中的。</p>
<p>当URL不在缓存中时，才让服务器做处理，并将生成的数据存储到缓存中，再返回它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cache = &#123;&#125;</span><br><span class="line"></span><br><span class="line">def get_page(url):</span><br><span class="line">  if cache.get(url):</span><br><span class="line">    return cache[url]</span><br><span class="line">  else:</span><br><span class="line">    data = get_data_from_server(url)</span><br><span class="line">    cache[url] = data</span><br><span class="line">    return data</span><br></pre></td></tr></table></figure></p>
<h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><p>这里我们没有讨论散列表内部的原理，但是我们依旧需要考虑散列表的性能，我们需要搞清楚什么是冲突。</p>
<p>之前谈到散列函数总是将不同的输入映射到不同的索引，这句话实际上是有问题的。因为这只是最理想的情况，实际上散列函数可能将不同的输入映射到同一个索引。这种情况就是冲突。处理冲突的方法有很多，最简单的办法就是：如果两个键映射到了同一个位置，就在这个位置存储一个链表，但是链表很长依然会影响散列表的性能。<br>因此，需要记住：</p>
<ol>
<li>散列函数很重要；</li>
<li>如果散列函数很好，这些链表就不会很长。<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3>在平均情况下，散列表执行各种操作的时间都为O(1)，O(1)被称为常量时间。<br>在最糟情况下，散列表所有操作的运行时间都为O(n)，—线性时间，这就比较慢了。</li>
</ol>
<p>所以，避开最糟情况很重要，为此我们需要：</p>
<ol>
<li>较低的填装因子</li>
<li>良好的散列函数</li>
</ol>
<h4 id="填装因子"><a href="#填装因子" class="headerlink" title="填装因子"></a>填装因子</h4><p>填装因子=散列表包含的元素数/位置总数</p>
<p>填装因子是用来度量散列表中有多少位置是空的。大于1意味着元素数量超过位置数，需要在散列表中添加位置，这被称为调整长度（resizing）。</p>
<p>填装因子越低，发生冲突的可能性越小，散列表的性能越高，一个不错的经验规则是：一旦填装因子大于0.7，就调整散列表的长度。</p>
<p>调整散列表的长度开销很大，所以最好不要频繁这样操作。但平均而言，即便考虑调整长度所需的时间，散列表操作所需的时间仍为O(1)。</p>
<h4 id="良好的散列函数"><a href="#良好的散列函数" class="headerlink" title="良好的散列函数"></a>良好的散列函数</h4><p>良好的散列函数，让数组中的值呈均匀分布。糟糕的散列函数让值扎堆，导致大量冲突。</p>
<p>SHA就是一种良好的散列函数，之后将会做详细的介绍。</p>
<p><strong>参考书目：</strong><br>[^1]: 《算法图解》【美】Aditya Bhargava. 编著</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://likernel.github.io/2017/07/21/散列表/" data-id="cjdiz17ys004igkuldbpu7v2i" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-快速排序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/21/快速排序/" class="article-date">
  <time datetime="2017-07-21T00:42:56.000Z" itemprop="datePublished">2017-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/21/快速排序/">快速排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Divide and conquer (D&amp;C) is an algorithm design paradigm based on multi-branched recursion. A divide and conquer algorithm works by recursively breaking down a problem into two or more sub-problems of the same or related type, until these become simple enough to be solved directly. The solutions to the sub-problems are then combined to give a solution to the original problem.</p>
<h3 id="D-amp-C"><a href="#D-amp-C" class="headerlink" title="D&amp;C"></a>D&amp;C</h3><p>分而治之，提供的是解决问题的一种思路。使用D&amp;C解决问题的过程包括两个步骤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.找出基线条件，这种条件必须尽可能简单。</span><br><span class="line">2.不断将问题分解（或者缩小规模），直到符合基线条件</span><br></pre></td></tr></table></figure></p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>下面以快排为例进行讲解，对排序算法来说，最简单的数组就是“不用排序”的数组。</p>
<p>1.空数组<br>2.数组中只有一个数字</p>
<p>因此基线条件为数组为空或者只包含一个元素。这时候只需原样返回数组即可。</p>
<p>要使用D&amp;C，需要将数组分解，直到满足基线条件。首先，从数组中选择一个元素作为基准值（pivot）。找出比基准值大的元素和比基准值小的元素。这个过程被称为分区（patitioning）。<br>现在你将数组分成了三个部分：</p>
<p>1.小于基准值的数组成的子数组<br>2.基准值<br>3.大于基准值的数组成的子数组</p>
<p><strong>快排代码：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def quicksort(arr):</span><br><span class="line">  if  len(arr)&lt;2:</span><br><span class="line">    return arr</span><br><span class="line">  else:</span><br><span class="line">    pivot = arr[0]</span><br><span class="line">    less = [i for i in arrray[1:] if i &lt;= pivot]</span><br><span class="line">    greater = [i for i in arrray[1:] if i &gt; pivot]</span><br><span class="line">    return quicksort(less) + [pivot] + quicksort(greater)</span><br></pre></td></tr></table></figure></p>
<p><strong>参考书目：</strong><br>[^1]: 《算法图解》【美】Aditya Bhargava. 编著</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://likernel.github.io/2017/07/21/快速排序/" data-id="cjdiz17ys004egkulf2rerg83" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/排序/">排序</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-递归" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/21/递归/" class="article-date">
  <time datetime="2017-07-21T00:40:52.000Z" itemprop="datePublished">2017-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/21/递归/">递归</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Recursion in computer science is a method where the solution to a problem depends on solutions to smaller instances of the same problem (as opposed to iteration).[1] The approach can be applied to many types of problems, and recursion is one of the central ideas of computer science.</p>
<p>Most computer programming languages support recursion by <strong>allowing a function to call itself</strong> within the program text. Some functional programming languages do not define any looping constructs but rely solely on recursion to repeatedly call code.</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归就是函数自己调用自己。在一些函数式编程中没有循环，只能用递归的方式来编写函数。递归可以让程序更加的清晰，并没有性能上的优势。至于选择，引用Stack Overflow上的一句话“如果使用循环，程序性能可能更高；如果使用递归程序可能更容易理解。如何选择，要看什么对你来说更重要。”</p>
<h3 id="基线条件与递归条件"><a href="#基线条件与递归条件" class="headerlink" title="基线条件与递归条件"></a>基线条件与递归条件</h3><p>编写递归函数时，一定要告诉它何时停止。每个递归函数都有两个部分，基线条件（base case）和递归条件（recursive case）。<br>基线条件就是何时不调用自己，递归条件是何时调用自己。</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈（stack）又名堆栈，它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。</p>
<h4 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h4><p>这个概念对理解递归很重要，这里便于理解不做专业的解释。调用栈是计算机内部使用的。调用一个函数的时候，该函数就进入调用栈，在栈顶添加了函数的内存块。调用另一个函数的时候，当前函数暂停并处于未完成状态。</p>
<h4 id="递归调用栈"><a href="#递归调用栈" class="headerlink" title="递归调用栈"></a>递归调用栈</h4><p>下面以阶乘factorial为例来展示一下递归调用栈。</p>
<p><strong>代码：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def fact(x):</span><br><span class="line">  if x == 1:</span><br><span class="line">    return 1</span><br><span class="line">  else:</span><br><span class="line">    return x*fact(x-1)</span><br></pre></td></tr></table></figure></p>
<p><strong>图解：</strong><br><img src="/assets/images/2017/07/fact.jpg" alt=""></p>
<h4 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h4><p>栈在递归中扮演了重要的角色，使用栈虽然方便，但要付出代价，每个函数调用都要占用一定内存，如果栈很高，会出现内存溢出。这时候有两种选择，使用循环或者尾递归。</p>
<p>尾递归就是用来减少这种堆栈的耗用，在这种递归代码在执行过程中是可以不需要回溯。<strong>一般是把当前的运算结果放在参数里传给下层函数。</strong>还是以阶乘为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def fact(x,a):</span><br><span class="line">    if x &lt; 0:</span><br><span class="line">        return 0</span><br><span class="line">    elif x == 0:</span><br><span class="line">        return 1</span><br><span class="line">    elif x == 1:</span><br><span class="line">        return a</span><br><span class="line">    else:</span><br><span class="line">        return fact(x-1,x*a)</span><br></pre></td></tr></table></figure></p>
<p>备注：上述尾递归就是用了一个参数a来维护递归的层次。同上过程中，最后不需要再依次回调这些函数，每次的结果a都存储了下来。</p>
<p><strong>参考书目：</strong><br>[^1]: 《算法图解》【美】Aditya Bhargava. 编著</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://likernel.github.io/2017/07/21/递归/" data-id="cjdiz17zc0052gkul3ko3y3rm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/7/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/9/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/BST/" style="font-size: 10px;">BST</a> <a href="/tags/Linux/" style="font-size: 14.29px;">Linux</a> <a href="/tags/PyQt5/" style="font-size: 11.43px;">PyQt5</a> <a href="/tags/django/" style="font-size: 12.86px;">django</a> <a href="/tags/docker/" style="font-size: 11.43px;">docker</a> <a href="/tags/leetcode/" style="font-size: 17.14px;">leetcode</a> <a href="/tags/python/" style="font-size: 20px;">python</a> <a href="/tags/web开发/" style="font-size: 12.86px;">web开发</a> <a href="/tags/并查集/" style="font-size: 10px;">并查集</a> <a href="/tags/排序/" style="font-size: 15.71px;">排序</a> <a href="/tags/操作系统/" style="font-size: 11.43px;">操作系统</a> <a href="/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/tags/数据结构/" style="font-size: 11.43px;">数据结构</a> <a href="/tags/数组/" style="font-size: 10px;">数组</a> <a href="/tags/机器学习/" style="font-size: 14.29px;">机器学习</a> <a href="/tags/深度学习/" style="font-size: 11.43px;">深度学习</a> <a href="/tags/算法/" style="font-size: 18.57px;">算法</a> <a href="/tags/链表/" style="font-size: 10px;">链表</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/01/31/Ubuntu下安装Docker/">Ubuntu下安装Docker</a>
          </li>
        
          <li>
            <a href="/2018/01/31/Docker基础/">Docker基础</a>
          </li>
        
          <li>
            <a href="/2018/01/25/PyQt5之信号与槽/">PyQt5之信号与槽</a>
          </li>
        
          <li>
            <a href="/2018/01/23/PyQt5-Pycharm环境搭建/">PyQt5+Pycharm环境搭建</a>
          </li>
        
          <li>
            <a href="/2017/12/28/scikit-neuralnetwork安装/">scikit-neuralnetwork安装</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 likernel<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives" class="mobile-nav-link">文章归档</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>