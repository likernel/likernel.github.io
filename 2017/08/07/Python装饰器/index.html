<!DOCTYPE html>
<html>
<head>
    

    

    
<!-- Baidu Tongji -->
<script>var _hmt = _hmt || []</script>
<script async src="//hm.baidu.com/hm.js?0cf5c472fa86e2055da7103f5ff06b27"></script>
<!-- End Baidu Tongji -->




    <meta charset="utf-8">
    
    
    
    <title>Python装饰器 | likernel</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="python">
    <meta name="description" content="装饰器是程序开发中经常会用到的一个功能，用好了装饰器，开发效率如虎添翼，同时，这也是Python面试中必问的问题。">
<meta name="keywords" content="python">
<meta property="og:type" content="article">
<meta property="og:title" content="Python装饰器">
<meta property="og:url" content="http://likernel.github.io/2017/08/07/Python装饰器/index.html">
<meta property="og:site_name" content="likernel">
<meta property="og:description" content="装饰器是程序开发中经常会用到的一个功能，用好了装饰器，开发效率如虎添翼，同时，这也是Python面试中必问的问题。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-02-11T15:35:15.190Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python装饰器">
<meta name="twitter:description" content="装饰器是程序开发中经常会用到的一个功能，用好了装饰器，开发效率如虎添翼，同时，这也是Python面试中必问的问题。">
    
        <link rel="alternate" type="application/atom+xml" title="likernel" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    
</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/head.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">likernel</h5>
          <a href="mailto:daqingv5@foxmail.com" title="daqingv5@foxmail.com" class="mail">daqingv5@foxmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/daqingv5" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://www.twitter.com/likernel" target="_blank" >
                <i class="icon icon-lg icon-twitter"></i>
                Twitter
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Python装饰器</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Python装饰器</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-08-06T22:54:17.000Z" itemprop="datePublished" class="page-time">
  2017-08-07
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#例子"><span class="post-toc-number">1.</span> <span class="post-toc-text">例子</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#需求"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">需求</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#重构方案一"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">重构方案一</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#重构方案二"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">重构方案二</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#重构方案三"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">重构方案三</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#原理"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">原理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#执行w1函数"><span class="post-toc-number">1.5.0.1.</span> <span class="post-toc-text">执行w1函数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#w1的返回值"><span class="post-toc-number">1.5.0.2.</span> <span class="post-toc-text">w1的返回值</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#再议装饰器"><span class="post-toc-number">2.</span> <span class="post-toc-text">再议装饰器</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#装饰器的应用"><span class="post-toc-number">3.</span> <span class="post-toc-text">装饰器的应用</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#被装饰的函数无参数"><span class="post-toc-number">4.</span> <span class="post-toc-text">被装饰的函数无参数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#被装饰的函数有参数"><span class="post-toc-number">5.</span> <span class="post-toc-text">被装饰的函数有参数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#被装饰的函数有不定长参数"><span class="post-toc-number">6.</span> <span class="post-toc-text">被装饰的函数有不定长参数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#装饰器中的return"><span class="post-toc-number">7.</span> <span class="post-toc-text">装饰器中的return</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#装饰器带参数-在原有装饰器的基础上，设置外部变量"><span class="post-toc-number">8.</span> <span class="post-toc-text">装饰器带参数,在原有装饰器的基础上，设置外部变量</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#类装饰器"><span class="post-toc-number">9.</span> <span class="post-toc-text">类装饰器</span></a></li></ol>
        </nav>
    </aside>


<article id="post-Python装饰器"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Python装饰器</h1>
        <div class="post-meta">
            <time class="post-time" title="2017-08-07 06:54:17" datetime="2017-08-06T22:54:17.000Z"  itemprop="datePublished">2017-08-07</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>装饰器是程序开发中经常会用到的一个功能，用好了装饰器，开发效率如虎添翼，同时，这也是Python面试中必问的问题。<br><a id="more"></a></p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>先看下下面的例子：</p>
<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>假设某公司已经实现了一系列基础功能，如：数据库操作、redis调用、监控API等功能。业务部门使用基础功能时，只需调用基础平台提供的功能即可。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def f1():</span><br><span class="line">    print(&apos;f1&apos;)</span><br><span class="line"></span><br><span class="line">def f2():</span><br><span class="line">    print(&apos;f2&apos;)</span><br></pre></td></tr></table></figure></p>
<p>业务部门需要使用基础平台提供的功能，直接调用就好了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1()</span><br><span class="line">f2()</span><br></pre></td></tr></table></figure></p>
<p>现在问题来了：以前基础平台的开发人员在写代码时候没有关注验证相关的问题，现在需要对基础平台的所有功能进行重构，为平台提供的所有功能添加验证机制，即：执行功能前，先进行验证。</p>
<h3 id="重构方案一"><a href="#重构方案一" class="headerlink" title="重构方案一"></a>重构方案一</h3><p>将需要进行的验证操作，写入到每个函数中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def f1():</span><br><span class="line">    # 验证1</span><br><span class="line">    # 验证2</span><br><span class="line">    # 验证3</span><br><span class="line">    print(&apos;f1&apos;)</span><br><span class="line"></span><br><span class="line">def f2():</span><br><span class="line">    # 验证1</span><br><span class="line">    # 验证2</span><br><span class="line">    # 验证3</span><br><span class="line">    print(&apos;f2&apos;)</span><br></pre></td></tr></table></figure></p>
<p>如果我们需要的验证操作很多，这种方式显然不合理。</p>
<h3 id="重构方案二"><a href="#重构方案二" class="headerlink" title="重构方案二"></a>重构方案二</h3><p>我们把验证操作封装到一个函数中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def check_login():</span><br><span class="line">    # 验证1</span><br><span class="line">    # 验证2</span><br><span class="line">    # 验证3</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></p>
<p>在函数中，对check_login()进行调用即可:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def f1():</span><br><span class="line"></span><br><span class="line">    check_login()</span><br><span class="line"></span><br><span class="line">    print(&apos;f1&apos;)</span><br><span class="line"></span><br><span class="line">def f2():</span><br><span class="line"></span><br><span class="line">    check_login()</span><br><span class="line"></span><br><span class="line">    print(&apos;f2&apos;)</span><br></pre></td></tr></table></figure></p>
<p>上面的做法可行，但不遵循开放封闭原则，虽然在这个原则是用的面向对象开发，但是也适用于函数式编程，简单来说，它规定已经实现的功能代码不允许被修改，但可以被扩展，即：</p>
<p>1.封闭：已实现的功能代码块<br>2.开放：对扩展开发</p>
<p>如果将开放封闭原则应用在上述需求中，那么就不允许在函数 f1 、f2的内部进行修改代码。</p>
<h3 id="重构方案三"><a href="#重构方案三" class="headerlink" title="重构方案三"></a>重构方案三</h3><p>使用装饰器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def w1(func):</span><br><span class="line">    def inner():</span><br><span class="line">        # 验证1</span><br><span class="line">        # 验证2</span><br><span class="line">        # 验证3</span><br><span class="line">        func()</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">@w1</span><br><span class="line">def f1():</span><br><span class="line">    print(&apos;f1&apos;)</span><br><span class="line">@w1</span><br><span class="line">def f2():</span><br><span class="line">    print(&apos;f2&apos;)</span><br></pre></td></tr></table></figure></p>
<p>对于上述代码，仅仅对基础平台的代码进行修改，就可以实现在其他人调用函数f1 f2之前都进行验证操作，并且业务部门无需做任何操作。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>单独以f1为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def w1(func):</span><br><span class="line">    def inner():</span><br><span class="line">        # 验证1</span><br><span class="line">        # 验证2</span><br><span class="line">        # 验证3</span><br><span class="line">        func()</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">@w1</span><br><span class="line">def f1():</span><br><span class="line">    print(&apos;f1&apos;)</span><br></pre></td></tr></table></figure></p>
<p>python解释器就会从上到下解释代码，步骤如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.def w1(func): ==&gt;将w1函数加载到内存</span><br><span class="line">2.@w1</span><br></pre></td></tr></table></figure></p>
<p>从表面上看解释器仅仅会解释这两句代码，因为函数在没有被调用之前其内部代码不会被执行。</p>
<p>但是@w1这一句代码里却有大文章，<code>@函数名</code>是python的一种语法糖。<br>@w1内部会执行以下操作：</p>
<h5 id="执行w1函数"><a href="#执行w1函数" class="headerlink" title="执行w1函数"></a>执行w1函数</h5><p>执行w1函数，并将@w1下面的函数作为w1函数的参数，即：@w1等价于 w1(f1)所以，内部就会去执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def w1(func):</span><br><span class="line">    def inner():</span><br><span class="line">        #验证 1</span><br><span class="line">        #验证 2</span><br><span class="line">        #验证 3</span><br><span class="line">        f1()     # func是参数，此时 func 等于 f1</span><br><span class="line">    return inner</span><br></pre></td></tr></table></figure></p>
<p>返回的inner，inner代表的是函数，非执行函数，其实就是将原来的f1函数塞进另外一个函数中。</p>
<h5 id="w1的返回值"><a href="#w1的返回值" class="headerlink" title="w1的返回值"></a>w1的返回值</h5><p>将执行完的w1函数返回值赋值给@w1下面的函数的函数名f1即将w1的返回值再重新赋值给f1，即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">新f1 = def inner():</span><br><span class="line">            #验证 1</span><br><span class="line">            #验证 2</span><br><span class="line">            #验证 3</span><br><span class="line">            原来f1()</span><br><span class="line">        return inner</span><br></pre></td></tr></table></figure></p>
<p>所以，以后业务部门想要执行f1 函数时，就会执行新f1函数，在新f1函数内部先执行验证，再执行原来的f1函数，然后将原来f1函数的返回值返回给了业务调用者。</p>
<h2 id="再议装饰器"><a href="#再议装饰器" class="headerlink" title="再议装饰器"></a>再议装饰器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#定义函数：完成包裹数据</span><br><span class="line">def makeBold(fn):</span><br><span class="line">    def wrapped():</span><br><span class="line">        return &quot;&lt;b&gt;&quot; + fn() + &quot;&lt;/b&gt;&quot;</span><br><span class="line">    return wrapped</span><br><span class="line"></span><br><span class="line">#定义函数：完成包裹数据</span><br><span class="line">def makeItalic(fn):</span><br><span class="line">    def wrapped():</span><br><span class="line">        return &quot;&lt;i&gt;&quot; + fn() + &quot;&lt;/i&gt;&quot;</span><br><span class="line">    return wrapped</span><br><span class="line"></span><br><span class="line">@makeBold</span><br><span class="line">def test1():</span><br><span class="line">    return &quot;hello world-1&quot;</span><br><span class="line"></span><br><span class="line">@makeItalic</span><br><span class="line">def test2():</span><br><span class="line">    return &quot;hello world-2&quot;</span><br><span class="line"></span><br><span class="line">@makeBold</span><br><span class="line">@makeItalic</span><br><span class="line">def test3():</span><br><span class="line">    return &quot;hello world-3&quot;</span><br><span class="line"></span><br><span class="line">print(test1()))</span><br><span class="line">print(test2()))</span><br><span class="line">print(test3()))</span><br></pre></td></tr></table></figure>
<p>运行结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;b&gt;hello world-1&lt;/b&gt;</span><br><span class="line">&lt;i&gt;hello world-2&lt;/i&gt;</span><br><span class="line">&lt;b&gt;&lt;i&gt;hello world-3&lt;/i&gt;&lt;/b&gt;</span><br></pre></td></tr></table></figure></p>
<p>备注：多个装饰器的调用顺序是自下往上，但是运行时的执行顺序是自上往下。</p>
<h2 id="装饰器的应用"><a href="#装饰器的应用" class="headerlink" title="装饰器的应用"></a>装饰器的应用</h2><p>1.引入日志<br>2.函数执行时间统计<br>3.执行函数前预备处理<br>4.执行函数后清理功能<br>5.权限校验等场景<br>6.缓存</p>
<h2 id="被装饰的函数无参数"><a href="#被装饰的函数无参数" class="headerlink" title="被装饰的函数无参数"></a>被装饰的函数无参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from time import ctime, sleep</span><br><span class="line"></span><br><span class="line">def timefun(func):</span><br><span class="line">    def wrappedfunc():</span><br><span class="line">        print(&quot;%s called at %s&quot;%(func.__name__, ctime()))</span><br><span class="line">        func()</span><br><span class="line">    return wrappedfunc</span><br><span class="line"></span><br><span class="line">@timefun</span><br><span class="line">def foo():</span><br><span class="line">    print(&quot;I am foo&quot;)</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">sleep(2)</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<p>上面代码理解装饰器执行行为可理解成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo = timefun(foo)</span><br><span class="line">#foo先作为参数赋值给func后,foo接收指向timefun返回的wrappedfunc</span><br><span class="line">foo()</span><br><span class="line">#调用foo(),即等价调用wrappedfunc()</span><br><span class="line">#内部函数wrappedfunc被引用，所以外部函数的func变量(自由变量)并没有释放</span><br><span class="line">#func里保存的是原foo函数对象</span><br></pre></td></tr></table></figure></p>
<h2 id="被装饰的函数有参数"><a href="#被装饰的函数有参数" class="headerlink" title="被装饰的函数有参数"></a>被装饰的函数有参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from time import ctime, sleep</span><br><span class="line"></span><br><span class="line">def timefun(func):</span><br><span class="line">    def wrappedfunc(a, b):</span><br><span class="line">        print(&quot;%s called at %s&quot;%(func.__name__, ctime()))</span><br><span class="line">        print(a, b)</span><br><span class="line">        func(a, b)</span><br><span class="line">    return wrappedfunc</span><br><span class="line"></span><br><span class="line">@timefun</span><br><span class="line">def foo(a, b):</span><br><span class="line">    print(a+b)</span><br><span class="line"></span><br><span class="line">foo(3,5)</span><br><span class="line">sleep(2)</span><br><span class="line">foo(2,4)</span><br></pre></td></tr></table></figure>
<h2 id="被装饰的函数有不定长参数"><a href="#被装饰的函数有不定长参数" class="headerlink" title="被装饰的函数有不定长参数"></a>被装饰的函数有不定长参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from time import ctime, sleep</span><br><span class="line"></span><br><span class="line">def timefun(func):</span><br><span class="line">    def wrappedfunc(*args, **kwargs):</span><br><span class="line">        print(&quot;%s called at %s&quot;%(func.__name__, ctime()))</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">    return wrappedfunc</span><br><span class="line"></span><br><span class="line">@timefun</span><br><span class="line">def foo(a, b, c):</span><br><span class="line">    print(a+b+c)</span><br><span class="line"></span><br><span class="line">foo(3,5,7)</span><br><span class="line">sleep(2)</span><br><span class="line">foo(2,4,9)</span><br></pre></td></tr></table></figure>
<h2 id="装饰器中的return"><a href="#装饰器中的return" class="headerlink" title="装饰器中的return"></a>装饰器中的return</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from time import ctime, sleep</span><br><span class="line"></span><br><span class="line">def timefun(func):</span><br><span class="line">    def wrappedfunc():</span><br><span class="line">        print(&quot;%s called at %s&quot;%(func.__name__, ctime()))</span><br><span class="line">        func()</span><br><span class="line">    return wrappedfunc</span><br><span class="line"></span><br><span class="line">@timefun</span><br><span class="line">def foo():</span><br><span class="line">    print(&quot;I am foo&quot;)</span><br><span class="line"></span><br><span class="line">@timefun</span><br><span class="line">def getInfo():</span><br><span class="line">    return &apos;----hahah---&apos;</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">sleep(2)</span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(getInfo())</span><br></pre></td></tr></table></figure>
<p>一般情况下为了让装饰器更通用，可以有return</p>
<h2 id="装饰器带参数-在原有装饰器的基础上，设置外部变量"><a href="#装饰器带参数-在原有装饰器的基础上，设置外部变量" class="headerlink" title="装饰器带参数,在原有装饰器的基础上，设置外部变量"></a>装饰器带参数,在原有装饰器的基础上，设置外部变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#decorator2.py</span><br><span class="line"></span><br><span class="line">from time import ctime, sleep</span><br><span class="line"></span><br><span class="line">def timefun_arg(pre=&quot;hello&quot;):</span><br><span class="line">    def timefun(func):</span><br><span class="line">        def wrappedfunc():</span><br><span class="line">            print(&quot;%s called at %s %s&quot;%(func.__name__, ctime(), pre))</span><br><span class="line">            return func()</span><br><span class="line">        return wrappedfunc</span><br><span class="line">    return timefun</span><br><span class="line"></span><br><span class="line">@timefun_arg(&quot;test&quot;)</span><br><span class="line">def foo():</span><br><span class="line">    print(&quot;I am foo&quot;)</span><br><span class="line"></span><br><span class="line">@timefun_arg(&quot;python&quot;)</span><br><span class="line">def too():</span><br><span class="line">    print(&quot;I am too&quot;)</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">sleep(2)</span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line">too()</span><br><span class="line">sleep(2)</span><br><span class="line">too()</span><br></pre></td></tr></table></figure>
<p>可以理解为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo()==timefun_arg(&quot;test&quot;)(foo)()</span><br></pre></td></tr></table></figure></p>
<h2 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h2><p>装饰器函数其实是这样一个接口约束，它必须接受一个callable对象作为参数，然后返回一个callable对象。在Python中一般callable对象都是函数，但也有例外。只要某个对象重写了 __call__() 方法，那么这个对象就是callable的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Test():</span><br><span class="line">    def __call__(self):</span><br><span class="line">        print(&apos;call me!&apos;)</span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t()  # call me</span><br></pre></td></tr></table></figure></p>
<p>类装饰器demo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Test(object):</span><br><span class="line">    def __init__(self, func):</span><br><span class="line">        print(&quot;---初始化---&quot;)</span><br><span class="line">        print(&quot;func name is %s&quot;%func.__name__)</span><br><span class="line">        self.__func = func</span><br><span class="line">    def __call__(self):</span><br><span class="line">        print(&quot;---装饰器中的功能---&quot;)</span><br><span class="line">        self.__func()</span><br><span class="line">#说明：</span><br><span class="line">#1. 当用Test来装作装饰器对test函数进行装饰的时候，首先会创建Test的实例对象</span><br><span class="line">#    并且会把test这个函数名当做参数传递到__init__方法中</span><br><span class="line">#    即在__init__方法中的func变量指向了test函数体</span><br><span class="line">#</span><br><span class="line">#2. test函数相当于指向了用Test创建出来的实例对象</span><br><span class="line">#</span><br><span class="line">#3. 当在使用test()进行调用时，就相当于让这个对象()，因此会调用这个对象的__call__方法</span><br><span class="line">#</span><br><span class="line">#4. 为了能够在__call__方法中调用原来test指向的函数体，所以在__init__方法中就需要一个实例属性来保存这个函数体的引用</span><br><span class="line">#    所以才有了self.__func = func这句代码，从而在调用__call__方法中能够调用到test之前的函数体</span><br><span class="line">@Test</span><br><span class="line">def test():</span><br><span class="line">    print(&quot;----test---&quot;)</span><br><span class="line">test()</span><br><span class="line">showpy()#如果把这句话注释，重新运行程序，依然会看到&quot;--初始化--&quot;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---初始化---</span><br><span class="line">func name is test</span><br><span class="line">---装饰器中的功能---</span><br><span class="line">----test---</span><br></pre></td></tr></table></figure></p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2018-02-11T15:35:15.190Z" itemprop="dateUpdated">2018-02-11 23:35:15</time>
</span><br>


        
        转载请注明出处，原文链接：<a href="/2017/08/07/Python装饰器/" target="_blank" rel="external">http://likernel.github.io/2017/08/07/Python装饰器/</a>
        
    </div>
    
    <footer>
        <a href="http://likernel.github.io">
            <img src="/img/head.jpg" alt="likernel">
            likernel
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://likernel.github.io/2017/08/07/Python装饰器/&title=《Python装饰器》 — likernel&pic=http://likernel.github.io/img/head.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://likernel.github.io/2017/08/07/Python装饰器/&title=《Python装饰器》 — likernel&source=装饰器是程序开发中经常会用到的一个功能，用好了装饰器，开发效率如虎添翼，同时，这也是Python面试中必问的问题。" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://likernel.github.io/2017/08/07/Python装饰器/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Python装饰器》 — likernel&url=http://likernel.github.io/2017/08/07/Python装饰器/&via=http://likernel.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://likernel.github.io/2017/08/07/Python装饰器/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2017/08/07/Python作用域/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Python作用域</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2017/08/07/Python闭包/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Python闭包</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'false' == 'true',
            appId: "uXYvhiuon3PDtB04U5cybn5O-gzGzoHsz",
            appKey: "U2OaXISftiiRmTnfW8IfxDJQ",
            avatar: "mm",
            placeholder: "Just go go",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->




</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢你请我吃糖！
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/weipay.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/weipay.png" data-alipay="/img/alipay.png">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>likernel &copy; 2015 - 2018</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://likernel.github.io/2017/08/07/Python装饰器/&title=《Python装饰器》 — likernel&pic=http://likernel.github.io/img/head.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://likernel.github.io/2017/08/07/Python装饰器/&title=《Python装饰器》 — likernel&source=装饰器是程序开发中经常会用到的一个功能，用好了装饰器，开发效率如虎添翼，同时，这也是Python面试中必问的问题。" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://likernel.github.io/2017/08/07/Python装饰器/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Python装饰器》 — likernel&url=http://likernel.github.io/2017/08/07/Python装饰器/&via=http://likernel.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://likernel.github.io/2017/08/07/Python装饰器/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACLklEQVR42u3aQW7DMAwEwP7/0+65COzsUkkBy+NTYaSyRgeCFPnzEz/Hy3P2m9ffJyu3/zV8MDAwbss4Lp+zDyRvzr5yfTTXvzn9CgYGxgMYSSi83u7Zm2S719TrvWFgYGBcfzIJncmb/LsYGBgYecCdFbezA8LAwMDIi9jkyixJH/PVvlKLY2Bg3JCR37r//99f6W9gYGDcinGUzyxAt1d19a4wMDC2ZuQBLk/LZmMWyfs3X8HAwHgkIw+OM3ASjvN2KQYGxq6MvFzMm5Rtm3Ol0P2T4WJgYGzKaBf61IjGeoqJgYHxNMZKmzAHz4bDiiYoBgbG1oz835KauIW1mDeHi4GBsTVj5XK/Hfb6xqgHBgbGroyVoYoklWyTwvxSL5oZwcDA2IjRBr620G23WzdWMTAwtmYkmPbCK6cuTYi0uScGBsbNGetJW7vmSjpYdDkwMDC2YOQl6EqxmieCw2CNgYGxNSNPE2dRfBbE80CMgYHxNMYs/M1C5KwBEKWkGBgYmzLakjK5ys9hK62C0y4HBgbGpozkUr7d0Mr6SZDFwMB4JmN9K3njsx31eHOsGBgYmzKO8pmNXMymI+r6GwMDY1NGG+ZWlm5hbeKIgYGxN6MdjGibnclxfODIMDAwHsAoqt64hdAOjbVFLAYGBkbbSlwvO5dKVgwMDIzLRVdGK2ZtztMiFgMDY2tGPlraXuW3bYbZQWBgYOzNmCVts6Zje9324XENDAyM+zF+AQxeslB5YFzvAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



<!-- highlight.js代码高亮主题 script 引入-->
<script src="/plugins/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<!-- highlight.js代码高亮主题 script 引入-->

</body>
</html>
