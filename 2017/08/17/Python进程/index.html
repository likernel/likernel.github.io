<!DOCTYPE html>
<html>
<head>
    

    

    
<!-- Baidu Tongji -->
<script>var _hmt = _hmt || []</script>
<script async src="//hm.baidu.com/hm.js?0cf5c472fa86e2055da7103f5ff06b27"></script>
<!-- End Baidu Tongji -->




    <meta charset="utf-8">
    
    
    
    <title>Python进程 | likernel</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="python">
    <meta name="description" content="本文主要介绍和Python进程相关的内容。">
<meta name="keywords" content="python">
<meta property="og:type" content="article">
<meta property="og:title" content="Python进程">
<meta property="og:url" content="http://likernel.github.io/2017/08/17/Python进程/index.html">
<meta property="og:site_name" content="likernel">
<meta property="og:description" content="本文主要介绍和Python进程相关的内容。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-02-11T15:37:49.845Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python进程">
<meta name="twitter:description" content="本文主要介绍和Python进程相关的内容。">
    
        <link rel="alternate" type="application/atom+xml" title="likernel" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

    <link rel="stylesheet" href="/plugins/styles/dracula.css">
</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/head.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">likernel</h5>
          <a href="mailto:daqingv5@foxmail.com" title="daqingv5@foxmail.com" class="mail">daqingv5@foxmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/daqingv5" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://www.twitter.com/likernel" target="_blank" >
                <i class="icon icon-lg icon-twitter"></i>
                Twitter
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Python进程</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Python进程</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-08-16T21:31:54.000Z" itemprop="datePublished" class="page-time">
  2017-08-17
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#fork"><span class="post-toc-number">1.</span> <span class="post-toc-text">fork</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#multiprocessing"><span class="post-toc-number">2.</span> <span class="post-toc-text">multiprocessing</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Process"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">Process</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Process类常用方法："><span class="post-toc-number">2.1.1.</span> <span class="post-toc-text">Process类常用方法：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Process类常用属性："><span class="post-toc-number">2.1.2.</span> <span class="post-toc-text">Process类常用属性：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#创建函数并将其作为单个进程"><span class="post-toc-number">2.1.3.</span> <span class="post-toc-text">创建函数并将其作为单个进程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#创建函数并将其作为多个进程"><span class="post-toc-number">2.1.4.</span> <span class="post-toc-text">创建函数并将其作为多个进程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#将进程定义为类"><span class="post-toc-number">2.1.5.</span> <span class="post-toc-text">将进程定义为类</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#进程池Pool"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">进程池Pool</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Pool常用函数解析："><span class="post-toc-number">2.2.1.</span> <span class="post-toc-text">Pool常用函数解析：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#apply堵塞式"><span class="post-toc-number">2.2.2.</span> <span class="post-toc-text">apply堵塞式</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#进程间通信–Queue"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">进程间通信–Queue</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#进程池中的Queue"><span class="post-toc-number">2.3.1.</span> <span class="post-toc-text">进程池中的Queue</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-Python进程"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Python进程</h1>
        <div class="post-meta">
            <time class="post-time" title="2017-08-17 05:31:54" datetime="2017-08-16T21:31:54.000Z"  itemprop="datePublished">2017-08-17</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>本文主要介绍和Python进程相关的内容。<br><a id="more"></a></p>
<h1 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h1><p>Unix/Linux操作系统提供了一个fork()系统调用，用来把当前进程（父进程）复制了一份（子进程）。</p>
<p>在Python的os模块封装了常见的系统调用，其中就包括fork，可以在Python程序中轻松创建子进程：</p>
<pre><code>    import os

    pid = os.fork()

    if pid == 0:
        print(&#39;哈哈1&#39;)
    else:
        print(&#39;哈哈2&#39;)
</code></pre><p>1.程序执行到os.fork()时，操作系统会创建一个新的进程（子进程），然后复制父进程的所有信息到子进程中。<br>2.然后父进程和子进程都会从fork()函数中得到一个返回值，在子进程中这个值一定是0，而父进程中是子进程的 id号。</p>
<p>这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。</p>
<pre><code>import os

rpid = os.fork()
if rpid&lt;0:
    print(&quot;fork调用失败。&quot;)
elif rpid == 0:
    print(&quot;我是子进程（%s），我的父进程是（%s）&quot;%(os.getpid(),os.getppid()))
    x+=1
else:
    print(&quot;我是父进程（%s），我的子进程是（%s）&quot;%(os.getpid(),rpid))

print(&quot;父子进程都可以执行这里的代码&quot;)
</code></pre><p>结果：</p>
<pre><code>我是父进程（19360），我的子进程是（19361）
父子进程都可以执行这里的代码
我是子进程（19361），我的父进程是（19360）
父子进程都可以执行这里的代码
</code></pre><p>由于Windows没有fork调用，上面的代码在Windows上无法运行，这样显然不适合这种跨平台的开发，因此，Python提供一个multiprocessing模块来支持跨平台的多进程。</p>
<h1 id="multiprocessing"><a href="#multiprocessing" class="headerlink" title="multiprocessing"></a>multiprocessing</h1><p>python中的多线程其实并不是真正的多线程，如果想要充分地使用多核CPU的资源，在python中大部分情况需要使用多进程。Python提供了非常好用的多进程包multiprocessing，只需要定义一个函数，Python会完成其他所有事情。借助这个包，可以轻松完成从单进程到并发执行的转换。multiprocessing支持子进程、通信和共享数据、执行不同形式的同步，提供了Process、Queue、Pipe、Lock等组件。</p>
<h2 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h2><p>Process语法结构如下：</p>
<pre><code>Process([group [, target [, name [, args [, kwargs]]]]])
</code></pre><p>1.<code>target</code>：表示这个进程实例所调用对象；<br>2.<code>args</code>：表示调用对象的位置参数元组；<br>3.<code>kwargs</code>：表示调用对象的关键字参数字典；<br>4.<code>name</code>：为当前进程实例的别名；<br>5.<code>group</code>：大多数情况下用不到；</p>
<h3 id="Process类常用方法："><a href="#Process类常用方法：" class="headerlink" title="Process类常用方法："></a>Process类常用方法：</h3><p>1.<code>is_alive()</code>：判断进程实例是否还在执行；<br>2.<code>join([timeout])</code>：是否等待进程实例执行结束，或等待多少秒；<br>3.<code>start()</code>：启动进程实例（创建子进程）；<br>4.<code>run()</code>：如果没有给定target参数，对这个对象调用start()方法时，就将执行对象中的run()方法；<br>5.<code>terminate()</code>：不管任务是否完成，立即终止；</p>
<h3 id="Process类常用属性："><a href="#Process类常用属性：" class="headerlink" title="Process类常用属性："></a>Process类常用属性：</h3><p>1.<code>name</code>：当前进程实例别名，默认为Process-N，N为从1开始递增的整数；<br>2.<code>pid</code>：当前进程实例的PID值；</p>
<h3 id="创建函数并将其作为单个进程"><a href="#创建函数并将其作为单个进程" class="headerlink" title="创建函数并将其作为单个进程"></a>创建函数并将其作为单个进程</h3><pre><code>from multiprocessing import Process
import os
from time import sleep

# 子进程要执行的代码
def run_proc(name, age, **kwargs):
    for i in range(10):
        print(&#39;子进程运行中，name= %s,age=%d ,pid=%d...&#39; % (name, age,os.getpid()))
        print(kwargs)
        sleep(0.5)

if __name__==&#39;__main__&#39;:
    print(&#39;父进程 %d.&#39; % os.getpid())
    p = Process(target=run_proc, args=(&#39;test&#39;,18), kwargs={&quot;m&quot;:20})
    print(&#39;子进程将要执行&#39;)
    p.start()
    sleep(1)
    p.terminate()
    p.join()
    print(&#39;子进程已结束&#39;)
</code></pre><p>结果：</p>
<pre><code>父进程 21378.
子进程将要执行
子进程运行中，name= test,age=18 ,pid=21379...
{&#39;m&#39;: 20}
子进程运行中，name= test,age=18 ,pid=21379...
{&#39;m&#39;: 20}
子进程已结束
</code></pre><h3 id="创建函数并将其作为多个进程"><a href="#创建函数并将其作为多个进程" class="headerlink" title="创建函数并将其作为多个进程"></a>创建函数并将其作为多个进程</h3><pre><code>#coding=utf-8
from multiprocessing import Process
import time
import os

#两个子进程将会调用的两个方法
def  worker_1(interval):
    print(&quot;worker_1,父进程(%s),当前进程(%s)&quot;%(os.getppid(),os.getpid()))
    t_start = time.time()
    time.sleep(interval) #程序将会被挂起interval秒
    t_end = time.time()
    print(&quot;worker_1,执行时间为&#39;%0.2f&#39;秒&quot;%(t_end - t_start))

def  worker_2(interval):
    print(&quot;worker_2,父进程(%s),当前进程(%s)&quot;%(os.getppid(),os.getpid()))
    t_start = time.time()
    time.sleep(interval)
    t_end = time.time()
    print(&quot;worker_2,执行时间为&#39;%0.2f&#39;秒&quot;%(t_end - t_start))

#输出当前程序的ID
print(&quot;进程ID：%s&quot;%os.getpid())

#创建两个进程对象，target指向这个进程对象要执行的对象名称，
#args后面的元组中，是要传递给worker_1方法的参数，
#因为worker_1方法就一个interval参数，这里传递一个整数2给它，
#如果不指定name参数，默认的进程对象名称为Process-N，N为一个递增的整数
p1=Process(target=worker_1,args=(2,))
p2=Process(target=worker_2,name=&quot;dongGe&quot;,args=(1,))

#使用&quot;进程对象名称.start()&quot;来创建并执行一个子进程，
#这两个进程对象在start后，就会分别去执行worker_1和worker_2方法中的内容
p1.start()
p2.start()

#同时父进程仍然往下执行，如果p2进程还在执行，将会返回True
print(&quot;p2.is_alive=%s&quot;%p2.is_alive())

#输出p1和p2进程的别名和pid
print(&quot;p1.name=%s&quot;%p1.name)
print(&quot;p1.pid=%s&quot;%p1.pid)
print(&quot;p2.name=%s&quot;%p2.name)
print(&quot;p2.pid=%s&quot;%p2.pid)

#join括号中不携带参数，表示父进程在这个位置要等待p1进程执行完成后，
#再继续执行下面的语句，一般用于进程间的数据同步，如果不写这一句，
#下面的is_alive判断将会是True，在shell（cmd）里面调用这个程序时
#可以完整的看到这个过程，大家可以尝试着将下面的这条语句改成p1.join(1)，
#因为p2需要2秒以上才可能执行完成，父进程等待1秒很可能不能让p1完全执行完成，
#所以下面的print会输出True，即p1仍然在执行
p1.join()
print(&quot;p1.is_alive=%s&quot;%p1.is_alive())
</code></pre><p>结果:</p>
<pre><code>进程ID：19866
p2.is_alive=True
p1.name=Process-1
p1.pid=19867
p2.name=dongGe
p2.pid=19868
worker_1,父进程(19866),当前进程(19867)
worker_2,父进程(19866),当前进程(19868)
worker_2,执行时间为&#39;1.00&#39;秒
worker_1,执行时间为&#39;2.00&#39;秒
p1.is_alive=False
</code></pre><h3 id="将进程定义为类"><a href="#将进程定义为类" class="headerlink" title="将进程定义为类"></a>将进程定义为类</h3><p>创建新的进程还能够使用类的方式，可以自定义一个类，继承Process类，每次实例化这个类的时候，就等同于实例化一个进程对象，请看下面的实例：</p>
<pre><code>from multiprocessing import Process
import time
import os

#继承Process类
class Process_Class(Process):
    #因为Process类本身也有__init__方法，这个子类相当于重写了这个方法，
    #但这样就会带来一个问题，我们并没有完全的初始化一个Process类，所以就不能使用从这个类继承的一些方法和属性，
    #最好的方法就是将继承类本身传递给Process.__init__方法，完成这些初始化操作
    def __init__(self,interval):
        Process.__init__(self)
        self.interval = interval

    #重写了Process类的run()方法
    def run(self):
        print(&quot;子进程(%s) 开始执行，父进程为（%s）&quot;%(os.getpid(),os.getppid()))
        t_start = time.time()
        time.sleep(self.interval)
        t_stop = time.time()
        print(&quot;(%s)执行结束，耗时%0.2f秒&quot;%(os.getpid(),t_stop-t_start))

if __name__==&quot;__main__&quot;:
    t_start = time.time()
    print(&quot;当前程序进程(%s)&quot;%os.getpid())        
    p1 = Process_Class(2)
    #对一个不包含target属性的Process类执行start()方法，就会运行这个类中的run()方法，所以这里会执行p1.run()
    p1.start()
    p1.join()
    t_stop = time.time()
    print(&quot;(%s)执行结束，耗时%0.2f&quot;%(os.getpid(),t_stop-t_start))
</code></pre><h2 id="进程池Pool"><a href="#进程池Pool" class="headerlink" title="进程池Pool"></a>进程池Pool</h2><p>当需要创建的子进程数量不多时，可以直接利用multiprocessing中的Process动态成生多个进程，但如果是上百甚至上千个目标，手动的去创建进程的工作量巨大，此时就可以用到multiprocessing模块提供的Pool方法。</p>
<p>初始化Pool时，可以指定一个最大进程数，当有新的请求提交到Pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程来执行，请看下面的实例：</p>
<pre><code>from multiprocessing import Pool
import os,time,random

def worker(msg):
    t_start = time.time()
    print(&quot;%s开始执行,进程号为%d&quot;%(msg,os.getpid()))
    #random.random()随机生成0~1之间的浮点数
    time.sleep(random.random()*2)
    t_stop = time.time()
    print(msg,&quot;执行完毕，耗时%0.2f&quot;%(t_stop-t_start))

po=Pool(3) #定义一个进程池，最大进程数3
for i in range(0,10):
    #Pool.apply_async(要调用的目标,(传递给目标的参数元祖,))
    #每次循环将会用空闲出来的子进程去调用目标
    po.apply_async(worker,(i,))

print(&quot;----start----&quot;)
po.close() #关闭进程池，关闭后po不再接收新的请求
po.join() #等待po中所有子进程执行完成，必须放在close语句之后
print(&quot;-----end-----&quot;)
</code></pre><p>运行结果:</p>
<pre><code>----start----
0开始执行,进程号为21466
1开始执行,进程号为21468
2开始执行,进程号为21467
0 执行完毕，耗时1.01
3开始执行,进程号为21466
2 执行完毕，耗时1.24
4开始执行,进程号为21467
3 执行完毕，耗时0.56
5开始执行,进程号为21466
1 执行完毕，耗时1.68
6开始执行,进程号为21468
4 执行完毕，耗时0.67
7开始执行,进程号为21467
5 执行完毕，耗时0.83
8开始执行,进程号为21466
6 执行完毕，耗时0.75
9开始执行,进程号为21468
7 执行完毕，耗时1.03
8 执行完毕，耗时1.05
9 执行完毕，耗时1.69
-----end-----
</code></pre><h3 id="Pool常用函数解析："><a href="#Pool常用函数解析：" class="headerlink" title="Pool常用函数解析："></a>Pool常用函数解析：</h3><p>1.<code>apply_async(func[, args[, kwds]])</code>：使用非阻塞方式调用func（并行执行，堵塞方式必须等待上一个进程退出才能执行下一个进程），args为传递给func的参数列表，kwds为传递给func的关键字参数列表；<br>2.<code>apply(func[, args[, kwds]])</code>：使用阻塞方式调用func<br>3.<code>close()</code>：关闭Pool，使其不再接受新的任务；<br>4.<code>terminate()</code>：不管任务是否完成，立即终止；<br>5.<code>join()</code>：主进程阻塞，等待子进程的退出， 必须在close或terminate之后使用；</p>
<h3 id="apply堵塞式"><a href="#apply堵塞式" class="headerlink" title="apply堵塞式"></a>apply堵塞式</h3><pre><code>from multiprocessing import Pool
import os,time,random

def worker(msg):
    t_start = time.time()
    print(&quot;%s开始执行,进程号为%d&quot;%(msg,os.getpid()))
    #random.random()随机生成0~1之间的浮点数
    time.sleep(random.random()*2)
    t_stop = time.time()
    print(msg,&quot;执行完毕，耗时%0.2f&quot;%(t_stop-t_start))

po=Pool(3) #定义一个进程池，最大进程数3
for i in range(0,10):
    po.apply(worker,(i,))

print(&quot;----start----&quot;)
po.close() #关闭进程池，关闭后po不再接收新的请求
po.join() #等待po中所有子进程执行完成，必须放在close语句之后
print(&quot;-----end-----&quot;)
</code></pre><p>运行结果:</p>
<pre><code>0开始执行,进程号为21532
0 执行完毕，耗时1.91
1开始执行,进程号为21534
1 执行完毕，耗时1.72
2开始执行,进程号为21533
2 执行完毕，耗时0.50
3开始执行,进程号为21532
3 执行完毕，耗时1.27
4开始执行,进程号为21534
4 执行完毕，耗时1.05
5开始执行,进程号为21533
5 执行完毕，耗时1.60
6开始执行,进程号为21532
6 执行完毕，耗时0.25
7开始执行,进程号为21534
7 执行完毕，耗时0.63
8开始执行,进程号为21533
8 执行完毕，耗时1.21
9开始执行,进程号为21532
9 执行完毕，耗时0.60
----start----
-----end-----
</code></pre><h2 id="进程间通信–Queue"><a href="#进程间通信–Queue" class="headerlink" title="进程间通信–Queue"></a>进程间通信–Queue</h2><p>Process之间有时需要通信，操作系统提供了很多机制来实现进程间的通信。</p>
<p>可以使用multiprocessing模块的Queue实现多进程之间的数据传递，Queue本身是一个消息列队程序，首先用一个小实例来演示一下Queue的工作原理：</p>
<pre><code>#coding=utf-8
from multiprocessing import Queue
q=Queue(3) #初始化一个Queue对象，最多可接收三条put消息
q.put(&quot;消息1&quot;)
q.put(&quot;消息2&quot;)
print(q.full())  #False
q.put(&quot;消息3&quot;)
print(q.full()) #True

#因为消息列队已满下面的try都会抛出异常，第一个try会等待2秒后再抛出异常，第二个Try会立刻抛出异常
try:
    q.put(&quot;消息4&quot;,True,2)
except:
    print(&quot;消息列队已满，现有消息数量:%s&quot;%q.qsize())

try:
    q.put_nowait(&quot;消息4&quot;)
except:
    print(&quot;消息列队已满，现有消息数量:%s&quot;%q.qsize())

#推荐的方式，先判断消息列队是否已满，再写入
if not q.full():
    q.put_nowait(&quot;消息4&quot;)

#读取消息时，先判断消息列队是否为空，再读取
if not q.empty():
    for i in range(q.qsize()):
        print(q.get_nowait())
</code></pre><p>运行结果:</p>
<pre><code>False
True
消息列队已满，现有消息数量:3
消息列队已满，现有消息数量:3
消息1
消息2
消息3
</code></pre><p>初始化Queue()对象时（例如：q=Queue()），若括号中没有指定最大可接收的消息数量，或数量为负值，那么就代表可接受的消息数量没有上限（直到内存的尽头）；<br>1.Queue.qsize()：返回当前队列包含的消息数量；<br>2.Queue.empty()：如果队列为空，返回True，反之False ；<br>3.Queue.full()：如果队列满了，返回True,反之False；<br>4.Queue.get([block[, timeout]])：获取队列中的一条消息，然后将其从列队中移除，block默认值为True；<br>5.Queue.get_nowait()：相当Queue.get(False)；<br>6.Queue.put(item,[block[, timeout]])：将item消息写入队列，block默认值为True；<br>7.Queue.put_nowait(item)：相当Queue.put(item, False)；</p>
<p>###Queue实例<br>我们以Queue为例，在父进程中创建两个子进程，一个往Queue里写数据，一个从Queue里读数据：</p>
<pre><code>from multiprocessing import Process, Queue
import os, time, random

# 写数据进程执行的代码:
def write(q):
    for value in [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]:
        print &#39;Put %s to queue...&#39; % value
        q.put(value)
        time.sleep(random.random())

# 读数据进程执行的代码:
def read(q):
    while True:
        if not q.empty():
            value = q.get(True)
            print &#39;Get %s from queue.&#39; % value
            time.sleep(random.random())
        else:
            break

if __name__==&#39;__main__&#39;:
    # 父进程创建Queue，并传给各个子进程：
    q = Queue()
    pw = Process(target=write, args=(q,))
    pr = Process(target=read, args=(q,))
    # 启动子进程pw，写入:
    pw.start()    
    # 等待pw结束:
    pw.join()
    # 启动子进程pr，读取:
    pr.start()
    pr.join()
    # pr进程里是死循环，无法等待其结束，只能强行终止:
    print &#39;&#39;
    print &#39;所有数据都写入并且读完&#39;
</code></pre><h3 id="进程池中的Queue"><a href="#进程池中的Queue" class="headerlink" title="进程池中的Queue"></a>进程池中的Queue</h3><p>如果要使用Pool创建进程，就需要使用multiprocessing.Manager()中的Queue()，而不是multiprocessing.Queue()，否则会得到一条如下的错误信息：</p>
<p>RuntimeError: Queue objects should only be shared between processes through inheritance.</p>
<p>下面的实例演示了进程池中的进程如何通信：</p>
<pre><code>#coding=utf-8

#修改import中的Queue为Manager
from multiprocessing import Manager,Pool
import os,time,random

def reader(q):
    print(&quot;reader启动(%s),父进程为(%s)&quot;%(os.getpid(),os.getppid()))
    for i in range(q.qsize()):
        print(&quot;reader从Queue获取到消息：%s&quot;%q.get(True))

def writer(q):
    print(&quot;writer启动(%s),父进程为(%s)&quot;%(os.getpid(),os.getppid()))
    for i in &quot;dongGe&quot;:
        q.put(i)

if __name__==&quot;__main__&quot;:
    print(&quot;(%s) start&quot;%os.getpid())
    q=Manager().Queue() #使用Manager中的Queue来初始化
    po=Pool()
    #使用阻塞模式创建进程，这样就不需要在reader中使用死循环了，可以让writer完全执行完成后，再用reader去读取
    po.apply(writer,(q,))
    po.apply(reader,(q,))
    po.close()
    po.join()
    print(&quot;(%s) End&quot;%os.getpid())
</code></pre><p>运行结果:</p>
<pre><code>(21156) start
writer启动(21162),父进程为(21156)
reader启动(21162),父进程为(21156)
reader从Queue获取到消息：d
reader从Queue获取到消息：o
reader从Queue获取到消息：n
reader从Queue获取到消息：g
reader从Queue获取到消息：G
reader从Queue获取到消息：e
(21156) End
</code></pre>
        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2018-02-11T15:37:49.845Z" itemprop="dateUpdated">2018-02-11 23:37:49</time>
</span><br>


        
        转载请注明出处，原文链接：<a href="/2017/08/17/Python进程/" target="_blank" rel="external">http://likernel.github.io/2017/08/17/Python进程/</a>
        
    </div>
    
    <footer>
        <a href="http://likernel.github.io">
            <img src="/img/head.jpg" alt="likernel">
            likernel
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://likernel.github.io/2017/08/17/Python进程/&title=《Python进程》 — likernel&pic=http://likernel.github.io/img/head.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://likernel.github.io/2017/08/17/Python进程/&title=《Python进程》 — likernel&source=本文主要介绍和Python进程相关的内容。" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://likernel.github.io/2017/08/17/Python进程/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Python进程》 — likernel&url=http://likernel.github.io/2017/08/17/Python进程/&via=http://likernel.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://likernel.github.io/2017/08/17/Python进程/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2017/08/17/Python线程/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Python线程</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2017/08/15/python实现链表/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">python实现链表</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'false' == 'true',
            appId: "uXYvhiuon3PDtB04U5cybn5O-gzGzoHsz",
            appKey: "U2OaXISftiiRmTnfW8IfxDJQ",
            avatar: "mm",
            placeholder: "Just go go",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->




</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢你请我吃糖！
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/weipay.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/weipay.png" data-alipay="/img/alipay.png">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>likernel &copy; 2015 - 2018</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://likernel.github.io/2017/08/17/Python进程/&title=《Python进程》 — likernel&pic=http://likernel.github.io/img/head.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://likernel.github.io/2017/08/17/Python进程/&title=《Python进程》 — likernel&source=本文主要介绍和Python进程相关的内容。" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://likernel.github.io/2017/08/17/Python进程/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Python进程》 — likernel&url=http://likernel.github.io/2017/08/17/Python进程/&via=http://likernel.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://likernel.github.io/2017/08/17/Python进程/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACJklEQVR42u3aQW7DMAwEwPz/0ynQUy4OdkU3aKTxKXBSi+MDK4p8POLr+Xu9fn69c3W//c3Vk2+7MDAwvpbxfHvlC1z97VW4ybdJbBgYGOcwPpNk34eYgC/vY2BgYJTL53eStTAwMDAmj04ScREKBgYGxltGUsTmm7+83M23pLfV4hgYGF/IWGsMfObzn/c3MDAw/j3jWV5rCbQ9XKujwsDA2JrRHp/ljIQ0Sf3RDhcDA2MLRjJUMSkg8+eP2gMYGBgHMO4arUgO0ZLRsfa1YmBgnMNYe1C74cuL0roWx8DA2JSRh7X2bV7crhXAGBgYJzDa4a32cH8yZFb8BgMDY2vGpA3ZLty+mqSdgIGBcQKjHY9ICs55U7M9tsPAwNib0S6Zp8581qPFF7U4BgbGRoy1Td5kUzgvVqMiFgMDYwtGnc4GTYJ2yCxvbWJgYJzAyEvTdqgiD6gtnjEwMM5h5M3FxVS4VNyu/RvAwMA4gTEJIj9cW3uJUerHwMDYlJEcabVlanvoPyl6MTAwMPKjsby4bUe+IjwGBsbWjMkgRZuC89fRgjEwMPZmLB7Bx2El6bI9trsctsDAwNiUMd+6TVL2pGDGwMA4jZEk2fYdtGk6X6tuYWJgYGzEyJNgmy7Xwk1e0OVYGAYGxsGMZIQr2dK1d6KEjoGBgVG2OW+bWcvjwcDAOIDRFrF526DddLaDYhgYGCcwJpMaebjRxMfS9hQDA2Nrxg9S+/UbEqyx0AAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



<!-- highlight.js代码高亮主题 script 引入-->
<script src="/plugins/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<!-- highlight.js代码高亮主题 script 引入-->

</body>
</html>
